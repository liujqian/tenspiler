Please translate the following Python program using NumPy to an equivalent C Plus Plus program. Follow these rules while you translate. 1. Use vectors and nested vectors for multidimensional arrays. 2. Use int as the template argument to instantiate vector templates. If the computation involves floating point by nature, storing results to int vectors is ok. I understand there is a potential loss in precision. 3. Do not use unnecessary quantifiers such as const to modify the input arguments. 4. Use vector.push_back to add elements into the vector instead of making assignments to indices if possible. 5. If the original Python code uses NumPy vectorized APIs, replace them with explicit for loops in C Plus Plus. 6. The computation being done and the control structure should be preserved as much as possible. Don't try to be smart and make changes like adding a guard for divide-by-zero. 7. If some mathematical function cannot be translated to C Plus Plus directly, first consider canonicalizing the operator or using a for loop to achieve that (for example, using if branches to calculate absolute values, replacing np.sum with a for loop summation, np.square to self-multiplying the operand or np.pow with a for loop multiplication). If this is not possible, please try to use functions in cmath. If there is no function that can do the same in the cmath header, warn me of the problem. 8. The translated C Plus Plus code should be syntactically correct and compile without errors. 9. Do not create more intermediate variables than necessary. Try to keep the same number of variables as in the original Python code. 10. Ensure that the computation and logic remain the same between the Python and C Plus Plus versions. 11. If the function name ends with _modified or _standardized, please remove this suffix from the function name in the C Plus Plus version. 12. Do not add unnecessary explicit type casting. 13. Do not include headers that are not used in the code.

Here are some examples:
Python code:
def dot_modified(a: np.ndarray, b: np.ndarray) -> int:
    """
    Args:
        a: NumPy ndarray of shape (N,).
        b: NumPy ndarray of shape (N,).
    Returns:
        Scalar integer representing the dot product.
    """
    sum_val = np.zeros((1,))
    for i in range(a.shape[0]):
        sum_val[0] = sum_val[0] + a[i] * b[i]
    return sum_val[0]
C Plus Plus code:
#include <vector>
using namespace std;

int dot(vector<int> a, vector<int> b, int n) {
  int sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += a[i] * b[i];
  }
  return sum;
}
Python code:
def color_burn_8(base: np.ndarray, active: np.ndarray) -> np.ndarray:
    """
    Args:
        base: NumPy ndarray of shape (M, N).
        active: NumPy ndarray of shape (M, N).
    Returns:
        NumPy ndarray of shape (M, N) with int elements.
    """
    out = np.zeros((base.shape[0], base.shape[1]))
    for row in range(base.shape[0]):
        for col in range(base.shape[1]):
            if active[row, col] == 0:
                pixel = 32
            else:
                pixel = 32 - (32 - base[row, col]) / active[row, col]
            out[row, col] = pixel
    return out
C Plus Plus code:
vector<vector<int>> color_burn_8(vector<vector<int>> base, vector<vector<int>> active)
{
    vector<vector<int>> out;
    int m = base.size();
    int n = base[0].size();
	for (int row = 0; row < m; row++) {
        vector<int> row_vec;
		for (int col = 0; col < n; col++) {
            int pixel;
            if (active[row][col] == 0)
                pixel = 32;
            else
                pixel = 32 - (32 - base[row][col]) / active[row][col];
            row_vec.push_back(pixel);
		}
		out.push_back(row_vec);
	}
	return out;
}
Python code:
def rmsnorm_part1(input: np.ndarray, weight: np.ndarray) -> int:
    """
    Args:
        input: NumPy ndarray of shape (N,).
        weight: NumPy ndarray of shape (N,).
    Returns:
        S: int.
    """
    sum_val = 0
    for i in range(input.shape[0]):
        sum_val += input[i] * input[i]
    return sum_val
C Plus Plus code:
#include <vector>
using namespace std;

int rmsnorm_part1(vector<int> input, vector<int> weight) {
    int ss = 0;
    for (int i = 0; i < input.size(); i++)
        ss += input[i] * input[i];
    return ss;
}
Now please translate the following Python code:
def kernel_2mm(A: np.ndarray, B: np.ndarray, C: np.ndarray, D: np.ndarray, alpha, beta) -> np.ndarray:
    """
    Args:
        A: NumPy ndarray of shape (M, K).
        B: NumPy ndarray of shape (K, N).
        C: NumPy ndarray of shape (N, L).
        D: NumPy ndarray of shape (M, L).
        alpha: scalar multiplier.
        beta: scalar multiplier.
    Returns:
        S: NumPy ndarray of shape (M, L).
    """
    tmp = np.zeros((A.shape[0], B.shape[1]), dtype=A.dtype)
    for i in range(A.shape[0]):
        for j in range(B.shape[1]):
            tmp[i, j] = 0
            for k in range(A.shape[1]):
                tmp[i, j] += alpha * A[i, k] * B[k, j]
    S = np.zeros((A.shape[0], C.shape[1]), dtype=D.dtype)
    for i in range(A.shape[0]):
        for j in range(C.shape[1]):
            S[i, j] = beta * D[i, j]
            for k in range(tmp.shape[1]):
                S[i, j] += tmp[i, k] * C[k, j]
    return S


