{
    "blas-dot": {
        "elapsed_time": 2.231311714000185,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (Gt:Bool (list_length:Int b) (Lit:Int 0))) (Ge:Bool (list_length:Int b) n)) (dot_inv0:Bool a b i n sum)) (dot_ps:Bool a b n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (Gt:Bool (list_length:Int b) (Lit:Int 0))) (Ge:Bool (list_length:Int b) n)) (dot_inv0:Bool a b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (Gt:Bool (list_length:Int b) (Lit:Int 0))) (Ge:Bool (list_length:Int b) n)) (dot_inv0:Bool a b i n sum)) (dot_inv0:Bool a b (Add:Int i (Lit:Int 1)) n (Add:Int sum (Mul:Int (list_get:Int a i) (list_get:Int b i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (Gt:Bool (list_length:Int b) (Lit:Int 0))) (Ge:Bool (list_length:Int b) n)) (dot_inv0:Bool a b i n sum)) (dot_ps:Bool a b n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef dot_inv0(a, b, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(vec_elemwise_mul(list_take(b, i), list_take(a, i)))\n\n\n\ndef dot_ps(a, b, n, dot_rv)\ndot_rv == reduce_sum(vec_elemwise_mul(list_take(b, n), list_take(a, n)))\n\n\n\ndot synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int b n) (list_take:List Int a n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef dot_np (a, b, n):\n    return np.sum((b[:n]) * (a[:n]))\n\n####### glued code ########\n\ndef dot_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return dot_np(a, b, n)\n\nSynthesis took 2.0242021083831787 seconds\n",
        "stderr": ""
    },
    "blas-gemv": {
        "elapsed_time": 6.286634142001276,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont\nname: for.inc8<latch>\nname: for.body3\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont', 'for.body3', 'for.inc'], exits: ['for.cond'], latches: ['for.inc8']\nfound loop: header: for.cond1, body: ['for.body3'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %M.addr = alloca i32, align 4\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %j = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %M, i32* %M.addr, align 4\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %M.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end10\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %N.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %A, i64 %conv) #11\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %j, align 4\n  %conv6 = sext i32 %i9 to i64\n  %call7 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %x, i64 %conv6) #11\n  %i10 = load i32, i32* %call7, align 4\n  %mul = mul nsw i32 %i8, %i10\n  %i11 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i11, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i12 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i12, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %sum)\n  br label %invoke.cont\n  br label %for.inc8\n  %i13 = load i32, i32* %i, align 4\n  %inc9 = add nsw i32 %i13, 1\n  store i32 %inc9, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x))) (gemv_ps:Bool M N A x agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool M (Lit:Int 1)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) x)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i M) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x)) (gemv_inv1:Bool A M N (Lit:Int 0) (Lit:Int 0) x agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j N) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x)) (gemv_inv1:Bool A M N j sum x agg.result i)) (gemv_inv1:Bool A M N (Add:Int j (Lit:Int 1)) (Add:Int sum (Mul:Int (list_get:Int (matrix_get:List Int A i) j) (list_get:Int x j))) x agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j N)) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x)) (gemv_inv1:Bool A M N j sum x agg.result i)) (gemv_inv0:Bool A M N (list_append:List List Int agg.result sum) (Add:Int i (Lit:Int 1)) j sum x)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int A) M)) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (gemv_inv0:Bool A M N agg.result i j sum x))) (gemv_ps:Bool M N A x agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef gemv_inv0(A, M, N, agg.result, i, j, sum, x)\ni >= 0 and i <= M and agg.result == matrix_vec_mul(matrix_col_slice(matrix_take(A, i), 0, N), list_take(x, N))\n\n\n\ndef gemv_inv1(A, M, N, j, sum, x, agg.result, i)\ni >= 0 and i < M and j >= 0 and j <= N and sum == reduce_sum(vec_elemwise_mul(list_take(matrix_get(A, i), j), list_take(x, j))) and agg.result == matrix_vec_mul(matrix_col_slice(matrix_take(A, i), 0, N), list_take(x, N))\n\n\n\ndef gemv_ps(M, N, A, x, gemv_rv)\ngemv_rv == matrix_vec_mul(matrix_col_slice(matrix_take(A, M), 0, N), list_take(x, N))\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndef VECTOR_OUTER_LOOP_INDEX()\nFalse\n\n\n\ngemv synthesized: (matrix_vec_mul:List Int (matrix_col_slice:List Int (matrix_take:List Int A M) (Lit:Int 0) N) (list_take:List Int x N))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef gemv_np (M, N, A, x):\n    return np.matmul(A[:M][:, 0:N], x[:N])\n\n####### glued code ########\n\ndef gemv_np_glued (M, N, A, x):\n    A = np.array(A).astype(np.int32)\n    x = np.array(x).astype(np.int32)\n    return gemv_np(M, N, A, x)\n\nSynthesis took 6.068611145019531 seconds\n",
        "stderr": ""
    },
    "blas-ger": {
        "elapsed_time": 24.706393857000876,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/blas/ger_.cc:  tenspiler/c2taco/cpp/for_synthesis/blas/ger_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> ger(int M, int N, vector<int> x, vector<int> y, vector<vector<int>> A) {\n    vector<vector<int>> updatedA;\n    for (int i = 0; i < M; ++i) {\n        vector<int> row;\n        for (int j = 0; j < N; ++j) {\n            row.push_back(A[i][j] + x[i] * y[j]);\n        }\n        updatedA.push_back(row);\n    }\n    return updatedA;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/blas/ger_.cc:  tenspiler/c2taco/cpp/for_synthesis/blas/ger_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> ger(int M, int N, vector<int> x, vector<int> y, vector<vector<int>> A) {\n    vector<vector<int>> updatedA;\n    for (int i = 0; i < M; ++i) {\n        vector<int> row;\n        for (int j = 0; j < N; ++j) {\n            row.push_back(A[i][j] + x[i] * y[j]);\n        }\n        updatedA.push_back(row);\n    }\n    return updatedA;\n}\nPush statement: row.push_back(A[i][j] + x[i] * y[j])\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb17\nname: for.end\nname: invoke.cont10\nname: for.inc11<latch>\nname: bb16\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb16\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb17', 'for.end', 'invoke.cont10', 'bb16', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc11']\nfound loop: header: for.cond1, body: ['bb16', 'for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %M.addr = alloca i32, align 4\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %M, i32* %M.addr, align 4\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %M.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %bb, label %bb15\n  br label %for.body\n  br label %for.end13\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector.0\"* %row) #10\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %N.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %bb16, label %bb17\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %bb18, label %bb19\n  br label %for.body3\n  br label %for.end\n  br label %nrvo.skipdtor\n  br label %nrvo.unused\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %A, i64 %conv) #10\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call, i64 %conv4) #10\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %i, align 4\n  %conv6 = sext i32 %i9 to i64\n  %call7 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %x, i64 %conv6) #10\n  %i10 = load i32, i32* %call7, align 4\n  %i11 = load i32, i32* %j, align 4\n  %conv8 = sext i32 %i11 to i64\n  %call9 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %y, i64 %conv8) #10\n  %i12 = load i32, i32* %call9, align 4\n  %mul = mul nsw i32 %i10, %i12\n  %add = add nsw i32 %i8, %mul\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i13 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i13, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row)\n  br label %invoke.cont10\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED2Ev(%\"class.std::__1::vector.0\"* %row) #10\n  br label %for.inc11\n  %i14 = load i32, i32* %i, align 4\n  %inc12 = add nsw i32 %i14, 1\n  store i32 %inc12, i32* %i, align 4\n  br label %for.cond\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y))) (ger_ps:Bool M N x y A agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool M (Lit:Int 1)) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ) x y)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i M) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N (Lit:Int 0) ref.tmp (list_empty:List Int ) x y agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j N) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N j ref.tmp row x y agg.result i)) (ger_inv1:Bool A M N (Add:Int j (Lit:Int 1)) (Add:Int (list_get:Int (matrix_get:List Int A i) j) (Mul:Int (list_get:Int x i) (list_get:Int y j))) (list_append:List List Int row (Add:Int (list_get:Int (matrix_get:List Int A i) j) (Mul:Int (list_get:Int x i) (list_get:Int y j)))) x y agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j N)) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N j ref.tmp row x y agg.result i)) (ger_inv0:Bool A M N (matrix_append:List List Int agg.result row) (Add:Int i (Lit:Int 1)) j ref.tmp row x y)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y))) (ger_ps:Bool M N x y A agg.result))]\nStrict grammar with list bound 2 failed\nTrying relaxed grammar...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool M (Lit:Int 1)) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ) x y)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i M) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N (Lit:Int 0) ref.tmp (list_empty:List Int ) x y agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j N) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N j ref.tmp row x y agg.result i)) (ger_inv1:Bool A M N (Add:Int j (Lit:Int 1)) (Add:Int (list_get:Int (matrix_get:List Int A i) j) (Mul:Int (list_get:Int x i) (list_get:Int y j))) (list_append:List List Int row (Add:Int (list_get:Int (matrix_get:List Int A i) j) (Mul:Int (list_get:Int x i) (list_get:Int y j)))) x y agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j N)) (Lt:Bool i M)) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (ger_inv1:Bool A M N j ref.tmp row x y agg.result i)) (ger_inv0:Bool A M N (matrix_append:List List Int agg.result row) (Add:Int i (Lit:Int 1)) j ref.tmp row x y)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i M))) (Ge:Bool M (Lit:Int 1))) (Ge:Bool N (Lit:Int 1))) (Gt:Bool (list_length:Int x) (Lit:Int 0))) (Ge:Bool (list_length:Int x) M)) (Gt:Bool (list_length:Int y) (Lit:Int 0))) (Ge:Bool (list_length:Int y) N)) (Gt:Bool (matrix_length:Int A) (Lit:Int 0))) (Ge:Bool (matrix_length:Int A) M)) (Gt:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) (Lit:Int 0))) (Ge:Bool (list_length:Int (matrix_get:List Int A (Lit:Int 0))) N)) (ger_inv0:Bool A M N agg.result i j ref.tmp row x y))) (ger_ps:Bool M N x y A agg.result))]\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 51, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/blas/ger_driver.py\", line 25, in <module>\n    run_synthesis_algorithm(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 139, in run_synthesis_algorithm\n    raise e\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 126, in run_synthesis_algorithm\n    run_synthesis_with_bound(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 67, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n"
    },
    "darknet-mult_add_into_cpu": {
        "elapsed_time": 2.2542818900001294,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %N.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %Z, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %X, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %i8 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i8 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %Y, i64 %conv3) #11\n  %i9 = load i32, i32* %call4, align 4\n  %mul = mul nsw i32 %i7, %i9\n  %add = add nsw i32 %i5, %mul\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z agg.result i ref.tmp))) (mult_add_into_cpu_ps:Bool N X Y Z agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool N (Lit:Int 1)) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z agg.result i ref.tmp)) (mult_add_into_cpu_inv0:Bool N X Y Z (list_append:List List Int agg.result (Add:Int (list_get:Int Z i) (Mul:Int (list_get:Int X i) (list_get:Int Y i)))) (Add:Int i (Lit:Int 1)) (Add:Int (list_get:Int Z i) (Mul:Int (list_get:Int X i) (list_get:Int Y i))))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int X) N)) (Ge:Bool (list_length:Int Y) N)) (Ge:Bool (list_length:Int Z) N)) (mult_add_into_cpu_inv0:Bool N X Y Z agg.result i ref.tmp))) (mult_add_into_cpu_ps:Bool N X Y Z agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef mult_add_into_cpu_inv0(N, X, Y, Z, agg.result, i, ref.tmp)\ni >= 0 and i <= N and agg.result == vec_elemwise_add(list_take(Z, i), vec_elemwise_mul(list_take(X, i), list_take(Y, i)))\n\n\n\ndef mult_add_into_cpu_ps(N, X, Y, Z, mult_add_into_cpu_rv)\nmult_add_into_cpu_rv == vec_elemwise_add(list_take(Z, N), vec_elemwise_mul(list_take(X, N), list_take(Y, N)))\n\n\n\nmult_add_into_cpu synthesized: (vec_elemwise_add:List Int (list_take:List Int Z N) (vec_elemwise_mul:List Int (list_take:List Int X N) (list_take:List Int Y N)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef mult_add_into_cpu_np (N, X, Y, Z):\n    return (Z[:N]) + ((X[:N]) * (Y[:N]))\n\n####### glued code ########\n\ndef mult_add_into_cpu_np_glued (N, X, Y, Z):\n    X = np.array(X).astype(np.int32)\n    Y = np.array(Y).astype(np.int32)\n    Z = np.array(Z).astype(np.int32)\n    return mult_add_into_cpu_np(N, X, Y, Z)\n\nSynthesis took 2.0772712230682373 seconds\n",
        "stderr": ""
    },
    "darknet-mag_array": {
        "elapsed_time": 2.202079323998987,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %sum = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mag_array_inv0:Bool a i n sum)) (mag_array_ps:Bool a n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mag_array_inv0:Bool a (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mag_array_inv0:Bool a i n sum)) (mag_array_inv0:Bool a (Add:Int i (Lit:Int 1)) n (Add:Int sum (Mul:Int (list_get:Int a i) (list_get:Int a i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mag_array_inv0:Bool a i n sum)) (mag_array_ps:Bool a n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef mag_array_inv0(a, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(vec_elemwise_mul(list_take(a, i), list_take(a, i)))\n\n\n\ndef mag_array_ps(a, n, mag_array_rv)\nmag_array_rv == reduce_sum(vec_elemwise_mul(list_take(a, n), list_take(a, n)))\n\n\n\nmag_array synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int a n) (list_take:List Int a n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef mag_array_np (a, n):\n    return np.sum((a[:n]) * (a[:n]))\n\n####### glued code ########\n\ndef mag_array_np_glued (a, n):\n    a = np.array(a).astype(np.int32)\n    return mag_array_np(a, n)\n\nSynthesis took 2.023017168045044 seconds\n",
        "stderr": ""
    },
    "darknet-mse_array": {
        "elapsed_time": 2.22132160900037,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %sum = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mse_array_inv0:Bool a i n sum)) (mse_array_ps:Bool a n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mse_array_inv0:Bool a (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mse_array_inv0:Bool a i n sum)) (mse_array_inv0:Bool a (Add:Int i (Lit:Int 1)) n (Add:Int sum (Mul:Int (list_get:Int a i) (list_get:Int a i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (mse_array_inv0:Bool a i n sum)) (mse_array_ps:Bool a n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef mse_array_inv0(a, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(vec_elemwise_mul(list_take(a, i), list_take(a, i)))\n\n\n\ndef mse_array_ps(a, n, mse_array_rv)\nmse_array_rv == reduce_sum(vec_elemwise_mul(list_take(a, n), list_take(a, n)))\n\n\n\nmse_array synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int a n) (list_take:List Int a n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef mse_array_np (a, n):\n    return np.sum((a[:n]) * (a[:n]))\n\n####### glued code ########\n\ndef mse_array_np_glued (a, n):\n    a = np.array(a).astype(np.int32)\n    return mse_array_np(a, n)\n\nSynthesis took 2.0313398838043213 seconds\n",
        "stderr": ""
    },
    "darknet-sum_array": {
        "elapsed_time": 2.1883186840004782,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %sum = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i5, %i4\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i7 = load i32, i32* %sum, align 4\n  ret i32 %i7\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (sum_array_inv0:Bool a i n sum)) (sum_array_ps:Bool a n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (sum_array_inv0:Bool a (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (sum_array_inv0:Bool a i n sum)) (sum_array_inv0:Bool a (Add:Int i (Lit:Int 1)) n (Add:Int sum (list_get:Int a i)))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int a) (Lit:Int 0))) (Ge:Bool (list_length:Int a) n)) (sum_array_inv0:Bool a i n sum)) (sum_array_ps:Bool a n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef sum_array_inv0(a, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(list_take(a, i))\n\n\n\ndef sum_array_ps(a, n, sum_array_rv)\nsum_array_rv == reduce_sum(list_take(a, n))\n\n\n\nsum_array synthesized: (reduce_sum:Int (list_take:List Int a n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef sum_array_np (a, n):\n    return np.sum(a[:n])\n\n####### glued code ########\n\ndef sum_array_np_glued (a, n):\n    a = np.array(a).astype(np.int32)\n    return sum_array_np(a, n)\n\nSynthesis took 2.0193357467651367 seconds\n",
        "stderr": ""
    },
    "darknet-scale_array": {
        "elapsed_time": 2.2122088659998553,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %s.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i32 %s, i32* %s.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %s.addr, align 4\n  %mul = mul nsw i32 %i5, %i6\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a agg.result i n ref.tmp s)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a agg.result i n ref.tmp s))) (scale_array_ps:Bool a n s agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a (list_empty:List Int ) (Lit:Int 0) n (Lit:Int 0) s)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a agg.result i n ref.tmp s)) (scale_array_inv0:Bool a (list_append:List List Int agg.result (Mul:Int (list_get:Int a i) s)) (Add:Int i (Lit:Int 1)) n (Mul:Int (list_get:Int a i) s) s)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a agg.result i n ref.tmp s)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (scale_array_inv0:Bool a agg.result i n ref.tmp s))) (scale_array_ps:Bool a n s agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef scale_array_inv0(a, agg.result, i, n, ref.tmp, s)\ni >= 0 and i <= n and agg.result == vec_scalar_mul(s, list_take(a, i))\n\n\n\ndef scale_array_ps(a, n, s, scale_array_rv)\nlist_eq(scale_array_rv, vec_scalar_mul(s, list_take(a, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef scale_array_np (a, n, s):\n    return (s) * (a[:n])\n\n####### glued code ########\n\ndef scale_array_np_glued (a, n, s):\n    a = np.array(a).astype(np.int32)\n    return scale_array_np(a, n, s)\n\nSynthesis took 2.0363070964813232 seconds\n",
        "stderr": ""
    },
    "darknet-matrix_add_matrix": {
        "elapsed_time": 6.553217644999677,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont15\nname: for.inc16<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont15', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc16']\nfound loop: header: for.cond1, body: ['for.body6', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %i = alloca i32, align 4\n  %j = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %conv = sext i32 %i2 to i64\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %from_matrix) #11\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %for.body, label %for.end18\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i3 = load i32, i32* %j, align 4\n  %conv2 = sext i32 %i3 to i64\n  %call3 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %from_matrix, i64 0) #11\n  %call4 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call3) #11\n  %cmp5 = icmp ult i64 %conv2, %call4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv7 = sext i32 %i4 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %from_matrix, i64 %conv7) #11\n  %i5 = load i32, i32* %j, align 4\n  %conv9 = sext i32 %i5 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i6 = load i32, i32* %call10, align 4\n  %i7 = load i32, i32* %i, align 4\n  %conv11 = sext i32 %i7 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %to_matrix, i64 %conv11) #11\n  %i8 = load i32, i32* %j, align 4\n  %conv13 = sext i32 %i8 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i9 = load i32, i32* %call14, align 4\n  %add = add nsw i32 %i6, %i9\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont15\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc16\n  %i11 = load i32, i32* %i, align 4\n  %inc17 = add nsw i32 %i11, 1\n  store i32 %inc17, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (matrix_length:Int from_matrix))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int from_matrix)))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix))) (matrix_add_matrix_ps:Bool from_matrix to_matrix agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1)) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool (matrix_empty:List Int ) from_matrix (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ) to_matrix)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (matrix_length:Int from_matrix)) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix)) (matrix_add_matrix_inv1:Bool from_matrix (Lit:Int 0) ref.tmp (list_empty:List Int ) to_matrix agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0)))) (Lt:Bool i (matrix_length:Int from_matrix))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix)) (matrix_add_matrix_inv1:Bool from_matrix j ref.tmp row_vec to_matrix agg.result i)) (matrix_add_matrix_inv1:Bool from_matrix (Add:Int j (Lit:Int 1)) (Add:Int (list_get:Int (matrix_get:List Int from_matrix i) j) (list_get:Int (matrix_get:List Int to_matrix i) j)) (list_append:List List Int row_vec (Add:Int (list_get:Int (matrix_get:List Int from_matrix i) j) (list_get:Int (matrix_get:List Int to_matrix i) j))) to_matrix agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))))) (Lt:Bool i (matrix_length:Int from_matrix))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix)) (matrix_add_matrix_inv1:Bool from_matrix j ref.tmp row_vec to_matrix agg.result i)) (matrix_add_matrix_inv0:Bool (matrix_append:List List Int agg.result row_vec) from_matrix (Add:Int i (Lit:Int 1)) j ref.tmp row_vec to_matrix)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (matrix_length:Int from_matrix))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int from_matrix)))) (Gt:Bool (matrix_length:Int from_matrix) (Lit:Int 1))) (Eq:Bool (matrix_length:Int from_matrix) (matrix_length:Int to_matrix))) (Eq:Bool (list_length:Int (matrix_get:List Int from_matrix (Lit:Int 0))) (list_length:Int (matrix_get:List Int to_matrix (Lit:Int 0))))) (matrix_add_matrix_inv0:Bool agg.result from_matrix i j ref.tmp row_vec to_matrix))) (matrix_add_matrix_ps:Bool from_matrix to_matrix agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matrix_add_matrix_inv0(agg.result, from_matrix, i, j, ref.tmp, row_vec, to_matrix)\ni >= 0 and i <= matrix_length(from_matrix) and agg.result == matrix_elemwise_add(matrix_take(from_matrix, i), matrix_take(to_matrix, i))\n\n\n\ndef matrix_add_matrix_inv1(from_matrix, j, ref.tmp, row_vec, to_matrix, agg.result, i)\ni >= 0 and i < matrix_length(from_matrix) and j >= 0 and j <= list_length(matrix_get(from_matrix, 0)) and row_vec == vec_elemwise_add(list_take(matrix_get(to_matrix, i), j), list_take(matrix_get(from_matrix, i), j)) and agg.result == matrix_elemwise_add(matrix_take(from_matrix, i), matrix_take(to_matrix, i))\n\n\n\ndef matrix_add_matrix_ps(from_matrix, to_matrix, matrix_add_matrix_rv)\nmatrix_add_matrix_rv == matrix_elemwise_add(from_matrix, to_matrix)\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmatrix_add_matrix synthesized: (matrix_elemwise_add:List Int from_matrix to_matrix)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matrix_add_matrix_np (from_matrix, to_matrix):\n    return (from_matrix) + (to_matrix)\n\n####### glued code ########\n\ndef matrix_add_matrix_np_glued (from_matrix, to_matrix):\n    from_matrix = np.array(from_matrix).astype(np.int32)\n    to_matrix = np.array(to_matrix).astype(np.int32)\n    return matrix_add_matrix_np(from_matrix, to_matrix)\n\nSynthesis took 6.2599523067474365 seconds\n",
        "stderr": ""
    },
    "darknet-ol_l2_cpu2": {
        "elapsed_time": 2.2484315689998766,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %diff = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %truth, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %pred, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %sub = sub nsw i32 %i5, %i7\n  store i32 %sub, i32* %diff, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %diff)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool agg.result diff i n pred truth)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool agg.result diff i n pred truth))) (ol_l2_cpu2_ps:Bool n pred truth agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0) n pred truth)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool agg.result diff i n pred truth)) (ol_l2_cpu2_inv0:Bool (list_append:List List Int agg.result (Sub:Int (list_get:Int truth i) (list_get:Int pred i))) (Sub:Int (list_get:Int truth i) (list_get:Int pred i)) (Add:Int i (Lit:Int 1)) n pred truth)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool agg.result diff i n pred truth)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu2_inv0:Bool agg.result diff i n pred truth))) (ol_l2_cpu2_ps:Bool n pred truth agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef ol_l2_cpu2_inv0(agg.result, diff, i, n, pred, truth)\ni >= 0 and i <= n and agg.result == vec_elemwise_sub(list_take(truth, i), list_take(pred, i))\n\n\n\ndef ol_l2_cpu2_ps(n, pred, truth, ol_l2_cpu2_rv)\nol_l2_cpu2_rv == vec_elemwise_sub(list_take(truth, n), list_take(pred, n))\n\n\n\nol_l2_cpu2 synthesized: (vec_elemwise_sub:List Int (list_take:List Int truth n) (list_take:List Int pred n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef ol_l2_cpu2_np (n, pred, truth):\n    return (truth[:n]) - (pred[:n])\n\n####### glued code ########\n\ndef ol_l2_cpu2_np_glued (n, pred, truth):\n    pred = np.array(pred).astype(np.int32)\n    truth = np.array(truth).astype(np.int32)\n    return ol_l2_cpu2_np(n, pred, truth)\n\nSynthesis took 2.0700864791870117 seconds\n",
        "stderr": ""
    },
    "darknet-translate_array": {
        "elapsed_time": 2.256950644999961,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %s.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i32 %s, i32* %s.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %s.addr, align 4\n  %add = add nsw i32 %i5, %i6\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a agg.result i n ref.tmp s)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a agg.result i n ref.tmp s))) (translate_array_ps:Bool a n s agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a (list_empty:List Int ) (Lit:Int 0) n (Lit:Int 0) s)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a agg.result i n ref.tmp s)) (translate_array_inv0:Bool a (list_append:List List Int agg.result (Add:Int (list_get:Int a i) s)) (Add:Int i (Lit:Int 1)) n (Add:Int (list_get:Int a i) s) s)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a agg.result i n ref.tmp s)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (translate_array_inv0:Bool a agg.result i n ref.tmp s))) (translate_array_ps:Bool a n s agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef translate_array_inv0(a, agg.result, i, n, ref.tmp, s)\ni >= 0 and i <= n and agg.result == vec_scalar_add(s, list_take(a, i))\n\n\n\ndef translate_array_ps(a, n, s, translate_array_rv)\nlist_eq(translate_array_rv, vec_scalar_add(s, list_take(a, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef translate_array_np (a, n, s):\n    return (s) + (a[:n])\n\n####### glued code ########\n\ndef translate_array_np_glued (a, n, s):\n    a = np.array(a).astype(np.int32)\n    return translate_array_np(a, n, s)\n\nSynthesis took 2.0479977130889893 seconds\n",
        "stderr": ""
    },
    "darknet-scale_matrix": {
        "elapsed_time": 2.4821426589987823,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont11\nname: for.inc12<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont11', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc12']\nfound loop: header: for.cond1, body: ['for.body6', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %scale.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %j = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %scale, i32* %scale.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %conv = sext i32 %i2 to i64\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %m) #11\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %for.body, label %for.end14\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i3 = load i32, i32* %j, align 4\n  %conv2 = sext i32 %i3 to i64\n  %call3 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %m, i64 0) #11\n  %call4 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call3) #11\n  %cmp5 = icmp ult i64 %conv2, %call4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv7 = sext i32 %i4 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %m, i64 %conv7) #11\n  %i5 = load i32, i32* %j, align 4\n  %conv9 = sext i32 %i5 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i6 = load i32, i32* %call10, align 4\n  %i7 = load i32, i32* %scale.addr, align 4\n  %mul = mul nsw i32 %i6, %i7\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont11\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc12\n  %i9 = load i32, i32* %i, align 4\n  %inc13 = add nsw i32 %i9, 1\n  store i32 %inc13, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (matrix_length:Int m))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int m)))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale))) (scale_matrix_ps:Bool m scale agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool (matrix_length:Int m) (Lit:Int 1)) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) m (Lit:Int 0) (list_empty:List Int ) scale)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (matrix_length:Int m)) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale)) (scale_matrix_inv1:Bool (Lit:Int 0) m ref.tmp (list_empty:List Int ) scale agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int m (Lit:Int 0)))) (Lt:Bool i (matrix_length:Int m))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale)) (scale_matrix_inv1:Bool j m ref.tmp row_vec scale agg.result i)) (scale_matrix_inv1:Bool (Add:Int j (Lit:Int 1)) m (Mul:Int (list_get:Int (matrix_get:List Int m i) j) scale) (list_append:List List Int row_vec (Mul:Int (list_get:Int (matrix_get:List Int m i) j) scale)) scale agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int m (Lit:Int 0))))) (Lt:Bool i (matrix_length:Int m))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale)) (scale_matrix_inv1:Bool j m ref.tmp row_vec scale agg.result i)) (scale_matrix_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j m ref.tmp row_vec scale)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (matrix_length:Int m))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int m)))) (Ge:Bool (matrix_length:Int m) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int m (Lit:Int 0))) (Lit:Int 1))) (scale_matrix_inv0:Bool agg.result i j m ref.tmp row_vec scale))) (scale_matrix_ps:Bool m scale agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef scale_matrix_inv0(agg.result, i, j, m, ref.tmp, row_vec, scale)\ni >= 0 and i <= matrix_length(m) and agg.result == matrix_scalar_mul(scale, matrix_take(m, i))\n\n\n\ndef scale_matrix_inv1(j, m, ref.tmp, row_vec, scale, agg.result, i)\ni >= 0 and i < matrix_length(m) and j >= 0 and j <= list_length(matrix_get(m, 0)) and row_vec == vec_scalar_mul(scale, list_take(matrix_get(m, i), j)) and agg.result == matrix_scalar_mul(scale, matrix_take(m, i))\n\n\n\ndef scale_matrix_ps(m, scale, scale_matrix_rv)\nscale_matrix_rv == matrix_scalar_mul(scale, m)\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nscale_matrix synthesized: (matrix_scalar_mul:List Int scale m)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef scale_matrix_np (m, scale):\n    return (scale) * (m)\n\n####### glued code ########\n\ndef scale_matrix_np_glued (m, scale):\n    m = np.array(m).astype(np.int32)\n    return scale_matrix_np(m, scale)\n\nSynthesis took 2.221184015274048 seconds\n",
        "stderr": ""
    },
    "darknet-ol_l2_cpu1": {
        "elapsed_time": 2.281422639998709,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %i = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %diff = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %truth, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %pred, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %sub = sub nsw i32 %i5, %i7\n  store i32 %sub, i32* %diff, align 4\n  %i8 = load i32, i32* %diff, align 4\n  %i9 = load i32, i32* %diff, align 4\n  %mul = mul nsw i32 %i8, %i9\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool agg.result diff i n pred ref.tmp truth)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool agg.result diff i n pred ref.tmp truth))) (ol_l2_cpu1_ps:Bool n pred truth agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0) n pred (Lit:Int 0) truth)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool agg.result diff i n pred ref.tmp truth)) (ol_l2_cpu1_inv0:Bool (list_append:List List Int agg.result (Mul:Int (Sub:Int (list_get:Int truth i) (list_get:Int pred i)) (Sub:Int (list_get:Int truth i) (list_get:Int pred i)))) (Sub:Int (list_get:Int truth i) (list_get:Int pred i)) (Add:Int i (Lit:Int 1)) n pred (Mul:Int (Sub:Int (list_get:Int truth i) (list_get:Int pred i)) (Sub:Int (list_get:Int truth i) (list_get:Int pred i))) truth)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool agg.result diff i n pred ref.tmp truth)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int pred) n)) (Ge:Bool (list_length:Int truth) n)) (ol_l2_cpu1_inv0:Bool agg.result diff i n pred ref.tmp truth))) (ol_l2_cpu1_ps:Bool n pred truth agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef ol_l2_cpu1_inv0(agg.result, diff, i, n, pred, ref.tmp, truth)\ni >= 0 and i <= n and agg.result == vec_elemwise_mul(vec_elemwise_sub(list_take(pred, i), list_take(truth, i)), vec_elemwise_sub(list_take(pred, i), list_take(truth, i)))\n\n\n\ndef ol_l2_cpu1_ps(n, pred, truth, ol_l2_cpu1_rv)\nol_l2_cpu1_rv == vec_elemwise_mul(vec_elemwise_sub(list_take(pred, n), list_take(truth, n)), vec_elemwise_sub(list_take(pred, n), list_take(truth, n)))\n\n\n\nol_l2_cpu1 synthesized: (vec_elemwise_mul:List Int (vec_elemwise_sub:List Int (list_take:List Int pred n) (list_take:List Int truth n)) (vec_elemwise_sub:List Int (list_take:List Int pred n) (list_take:List Int truth n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef ol_l2_cpu1_np (n, pred, truth):\n    return ((pred[:n]) - (truth[:n])) * ((pred[:n]) - (truth[:n]))\n\n####### glued code ########\n\ndef ol_l2_cpu1_np_glued (n, pred, truth):\n    pred = np.array(pred).astype(np.int32)\n    truth = np.array(truth).astype(np.int32)\n    return ol_l2_cpu1_np(n, pred, truth)\n\nSynthesis took 2.1034841537475586 seconds\n",
        "stderr": ""
    },
    "dsp-vmul": {
        "elapsed_time": 2.21647669900085,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i5, %i7\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a agg.result b i n ref.tmp))) (vmul_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a agg.result b i n ref.tmp)) (vmul_inv0:Bool a (list_append:List List Int agg.result (Mul:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Mul:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vmul_inv0:Bool a agg.result b i n ref.tmp))) (vmul_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vmul_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_mul(list_take(a, i), list_take(b, i))\n\n\n\ndef vmul_ps(a, b, n, vmul_rv)\nvmul_rv == vec_elemwise_mul(list_take(a, n), list_take(b, n))\n\n\n\nvmul synthesized: (vec_elemwise_mul:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vmul_np (a, b, n):\n    return (a[:n]) * (b[:n])\n\n####### glued code ########\n\ndef vmul_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return vmul_np(a, b, n)\n\nSynthesis took 2.0394604206085205 seconds\n",
        "stderr": ""
    },
    "dsp-vcopy": {
        "elapsed_time": 2.2093952449995413,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %call)\n  br label %invoke.cont\n  br label %for.inc\n  %i5 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i5, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a agg.result i n)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a agg.result i n))) (vcopy_ps:Bool a n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a (list_empty:List Int ) (Lit:Int 0) n)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a agg.result i n)) (vcopy_inv0:Bool a (list_append:List List Int agg.result (list_get:Int a i)) (Add:Int i (Lit:Int 1)) n)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a agg.result i n)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (vcopy_inv0:Bool a agg.result i n))) (vcopy_ps:Bool a n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vcopy_inv0(a, agg.result, i, n)\ni >= 0 and i <= n and agg.result == list_take(a, i)\n\n\n\ndef vcopy_ps(a, n, vcopy_rv)\nlist_eq(vcopy_rv, list_take(a, n))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vcopy_np (a, n):\n    return a[:n]\n\n####### glued code ########\n\ndef vcopy_np_glued (a, n):\n    a = np.array(a).astype(np.int32)\n    return vcopy_np(a, n)\n\nSynthesis took 2.0306475162506104 seconds\n",
        "stderr": ""
    },
    "dsp-vrecip": {
        "elapsed_time": 2.2223162790014612,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %div = sdiv i32 1, %i5\n  store i32 %div, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool agg.result arr i n ref.tmp))) (vrecip_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool agg.result arr i n ref.tmp)) (vrecip_inv0:Bool (list_append:List List Int agg.result (Div:Int (Lit:Int 1) (list_get:Int arr i))) arr (Add:Int i (Lit:Int 1)) n (Div:Int (Lit:Int 1) (list_get:Int arr i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vrecip_inv0:Bool agg.result arr i n ref.tmp))) (vrecip_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vrecip_inv0(agg.result, arr, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == scalar_vec_div(1, list_take(arr, i))\n\n\n\ndef vrecip_ps(arr, n, vrecip_rv)\nlist_eq(vrecip_rv, scalar_vec_div(1, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vrecip_np (arr, n):\n    return (1) // (arr[:n])\n\n####### glued code ########\n\ndef vrecip_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return vrecip_np(arr, n)\n\nSynthesis took 2.036358594894409 seconds\n",
        "stderr": ""
    },
    "dsp-matadd": {
        "elapsed_time": 8.453885165999964,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont10\nname: for.inc11<latch>\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont10', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc11']\nfound loop: header: for.cond1, body: ['for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %m.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %m, i32* %m.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %m.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end13\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %n.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %matA, i64 %conv) #11\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %i, align 4\n  %conv6 = sext i32 %i9 to i64\n  %call7 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %matB, i64 %conv6) #11\n  %i10 = load i32, i32* %j, align 4\n  %conv8 = sext i32 %i10 to i64\n  %call9 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call7, i64 %conv8) #11\n  %i11 = load i32, i32* %call9, align 4\n  %add = add nsw i32 %i8, %i11\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i12 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i12, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont10\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc11\n  %i13 = load i32, i32* %i, align 4\n  %inc12 = add nsw i32 %i13, 1\n  store i32 %inc12, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec))) (matadd_ps:Bool matA matB m n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool m (Lit:Int 1)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) m matA matB n (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i m) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matadd_inv1:Bool (Lit:Int 0) m matA matB n ref.tmp (list_empty:List Int ) agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j n) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matadd_inv1:Bool j m matA matB n ref.tmp row_vec agg.result i)) (matadd_inv1:Bool (Add:Int j (Lit:Int 1)) m matA matB n (Add:Int (list_get:Int (matrix_get:List Int matA i) j) (list_get:Int (matrix_get:List Int matB i) j)) (list_append:List List Int row_vec (Add:Int (list_get:Int (matrix_get:List Int matA i) j) (list_get:Int (matrix_get:List Int matB i) j))) agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j n)) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matadd_inv1:Bool j m matA matB n ref.tmp row_vec agg.result i)) (matadd_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j m matA matB n ref.tmp row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matadd_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec))) (matadd_ps:Bool matA matB m n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matadd_inv0(agg.result, i, j, m, matA, matB, n, ref.tmp, row_vec)\ni >= 0 and i <= m and agg.result == matrix_elemwise_add(matrix_col_slice(matrix_take(matA, i), 0, n), matrix_col_slice(matrix_take(matB, i), 0, n))\n\n\n\ndef matadd_inv1(j, m, matA, matB, n, ref.tmp, row_vec, agg.result, i)\ni >= 0 and i < m and j >= 0 and j <= n and row_vec == vec_elemwise_add(list_take(matrix_get(matA, i), j), list_take(matrix_get(matB, i), j)) and agg.result == matrix_elemwise_add(matrix_col_slice(matrix_take(matA, i), 0, n), matrix_col_slice(matrix_take(matB, i), 0, n))\n\n\n\ndef matadd_ps(matA, matB, m, n, matadd_rv)\nmatadd_rv == matrix_elemwise_add(matrix_col_slice(matrix_take(matA, m), 0, n), matrix_col_slice(matrix_take(matB, m), 0, n))\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmatadd synthesized: (matrix_elemwise_add:List Int (matrix_col_slice:List Int (matrix_take:List Int matA m) (Lit:Int 0) n) (matrix_col_slice:List Int (matrix_take:List Int matB m) (Lit:Int 0) n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matadd_np (matA, matB, m, n):\n    return (matA[:m][:, 0:n]) + (matB[:m][:, 0:n])\n\n####### glued code ########\n\ndef matadd_np_glued (matA, matB, m, n):\n    matA = np.array(matA).astype(np.int32)\n    matB = np.array(matB).astype(np.int32)\n    return matadd_np(matA, matB, m, n)\n\nSynthesis took 8.23800802230835 seconds\n",
        "stderr": ""
    },
    "dsp-vneg": {
        "elapsed_time": 2.2208020409998426,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %sub = sub nsw i32 0, %i5\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool agg.result arr i n ref.tmp))) (vneg_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool agg.result arr i n ref.tmp)) (vneg_inv0:Bool (list_append:List List Int agg.result (Sub:Int (Lit:Int 0) (list_get:Int arr i))) arr (Add:Int i (Lit:Int 1)) n (Sub:Int (Lit:Int 0) (list_get:Int arr i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vneg_inv0:Bool agg.result arr i n ref.tmp))) (vneg_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vneg_inv0(agg.result, arr, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == scalar_vec_sub(0, list_take(arr, i))\n\n\n\ndef vneg_ps(arr, n, vneg_rv)\nlist_eq(vneg_rv, scalar_vec_sub(0, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vneg_np (arr, n):\n    return (0) - (arr[:n])\n\n####### glued code ########\n\ndef vneg_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return vneg_np(arr, n)\n\nSynthesis took 2.0342986583709717 seconds\n",
        "stderr": ""
    },
    "dsp-voffset": {
        "elapsed_time": 2.212767023000197,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %v.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %v, i32* %v.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %v.addr, align 4\n  %add = add nsw i32 %i5, %i6\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool agg.result arr i n ref.tmp v)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool agg.result arr i n ref.tmp v))) (voffset_ps:Bool arr v n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0) v)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool agg.result arr i n ref.tmp v)) (voffset_inv0:Bool (list_append:List List Int agg.result (Add:Int (list_get:Int arr i) v)) arr (Add:Int i (Lit:Int 1)) n (Add:Int (list_get:Int arr i) v) v)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool agg.result arr i n ref.tmp v)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (voffset_inv0:Bool agg.result arr i n ref.tmp v))) (voffset_ps:Bool arr v n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef voffset_inv0(agg.result, arr, i, n, ref.tmp, v)\ni >= 0 and i <= n and agg.result == vec_scalar_add(v, list_take(arr, i))\n\n\n\ndef voffset_ps(arr, v, n, voffset_rv)\nlist_eq(voffset_rv, vec_scalar_add(v, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef voffset_np (arr, v, n):\n    return (v) + (arr[:n])\n\n####### glued code ########\n\ndef voffset_np_glued (arr, v, n):\n    arr = np.array(arr).astype(np.int32)\n    return voffset_np(arr, v, n)\n\nSynthesis took 2.040088176727295 seconds\n",
        "stderr": ""
    },
    "dsp-vscal": {
        "elapsed_time": 2.2506085919994803,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %v.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %v, i32* %v.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %v.addr, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv = sext i32 %i5 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i6 = load i32, i32* %call, align 4\n  %mul = mul nsw i32 %i4, %i6\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool agg.result arr i n ref.tmp v)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool agg.result arr i n ref.tmp v))) (vscal_ps:Bool arr v n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0) v)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool agg.result arr i n ref.tmp v)) (vscal_inv0:Bool (list_append:List List Int agg.result (Mul:Int v (list_get:Int arr i))) arr (Add:Int i (Lit:Int 1)) n (Mul:Int v (list_get:Int arr i)) v)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool agg.result arr i n ref.tmp v)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (vscal_inv0:Bool agg.result arr i n ref.tmp v))) (vscal_ps:Bool arr v n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vscal_inv0(agg.result, arr, i, n, ref.tmp, v)\ni >= 0 and i <= n and agg.result == vec_scalar_mul(v, list_take(arr, i))\n\n\n\ndef vscal_ps(arr, v, n, vscal_rv)\nlist_eq(vscal_rv, vec_scalar_mul(v, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vscal_np (arr, v, n):\n    return (v) * (arr[:n])\n\n####### glued code ########\n\ndef vscal_np_glued (arr, v, n):\n    arr = np.array(arr).astype(np.int32)\n    return vscal_np(arr, v, n)\n\nSynthesis took 2.033381223678589 seconds\n",
        "stderr": ""
    },
    "dsp-vadd": {
        "elapsed_time": 2.224636293000003,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %add = add nsw i32 %i5, %i7\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a agg.result b i n ref.tmp))) (vadd_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a agg.result b i n ref.tmp)) (vadd_inv0:Bool a (list_append:List List Int agg.result (Add:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Add:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vadd_inv0:Bool a agg.result b i n ref.tmp))) (vadd_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vadd_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_add(list_take(a, i), list_take(b, i))\n\n\n\ndef vadd_ps(a, b, n, vadd_rv)\nvadd_rv == vec_elemwise_add(list_take(a, n), list_take(b, n))\n\n\n\nvadd synthesized: (vec_elemwise_add:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vadd_np (a, b, n):\n    return (a[:n]) + (b[:n])\n\n####### glued code ########\n\ndef vadd_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return vadd_np(a, b, n)\n\nSynthesis took 2.045164108276367 seconds\n",
        "stderr": ""
    },
    "dsp-matscal": {
        "elapsed_time": 4.373206313000992,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont6\nname: for.inc7<latch>\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont6', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc7']\nfound loop: header: for.cond1, body: ['for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %val.addr = alloca i32, align 4\n  %m.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %val, i32* %val.addr, align 4\n  store i32 %m, i32* %m.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %m.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end9\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %n.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %mat, i64 %conv) #11\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %val.addr, align 4\n  %mul = mul nsw i32 %i8, %i9\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont6\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc7\n  %i11 = load i32, i32* %i, align 4\n  %inc8 = add nsw i32 %i11, 1\n  store i32 %inc8, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val))) (matscal_ps:Bool mat val m n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool m (Lit:Int 1)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) m mat n (Lit:Int 0) (list_empty:List Int ) val)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i m) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val)) (matscal_inv1:Bool (Lit:Int 0) m mat n ref.tmp (list_empty:List Int ) val agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j n) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val)) (matscal_inv1:Bool j m mat n ref.tmp row_vec val agg.result i)) (matscal_inv1:Bool (Add:Int j (Lit:Int 1)) m mat n (Mul:Int (list_get:Int (matrix_get:List Int mat i) j) val) (list_append:List List Int row_vec (Mul:Int (list_get:Int (matrix_get:List Int mat i) j) val)) val agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j n)) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val)) (matscal_inv1:Bool j m mat n ref.tmp row_vec val agg.result i)) (matscal_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j m mat n ref.tmp row_vec val)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int mat) m)) (Ge:Bool (list_length:Int (matrix_get:List Int mat (Lit:Int 0))) n)) (matscal_inv0:Bool agg.result i j m mat n ref.tmp row_vec val))) (matscal_ps:Bool mat val m n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matscal_inv0(agg.result, i, j, m, mat, n, ref.tmp, row_vec, val)\ni >= 0 and i <= m and agg.result == matrix_scalar_mul(val, matrix_col_slice(matrix_take(mat, i), 0, n))\n\n\n\ndef matscal_inv1(j, m, mat, n, ref.tmp, row_vec, val, agg.result, i)\ni >= 0 and i < m and j >= 0 and j <= n and row_vec == vec_scalar_mul(val, list_take(matrix_get(mat, i), j)) and agg.result == matrix_scalar_mul(val, matrix_col_slice(matrix_take(mat, i), 0, n))\n\n\n\ndef matscal_ps(mat, val, m, n, matscal_rv)\nmatscal_rv == matrix_scalar_mul(val, matrix_col_slice(matrix_take(mat, m), 0, n))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmatscal synthesized: (matrix_scalar_mul:List Int val (matrix_col_slice:List Int (matrix_take:List Int mat m) (Lit:Int 0) n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matscal_np (mat, val, m, n):\n    return (val) * (mat[:m][:, 0:n])\n\n####### glued code ########\n\ndef matscal_np_glued (mat, val, m, n):\n    mat = np.array(mat).astype(np.int32)\n    return matscal_np(mat, val, m, n)\n\nSynthesis took 4.176914930343628 seconds\n",
        "stderr": ""
    },
    "dsp-vsub": {
        "elapsed_time": 2.2323010000000068,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %sub = sub nsw i32 %i5, %i7\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a agg.result b i n ref.tmp))) (vsub_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a agg.result b i n ref.tmp)) (vsub_inv0:Bool a (list_append:List List Int agg.result (Sub:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Sub:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (vsub_inv0:Bool a agg.result b i n ref.tmp))) (vsub_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef vsub_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_sub(list_take(a, i), list_take(b, i))\n\n\n\ndef vsub_ps(a, b, n, vsub_rv)\nvsub_rv == vec_elemwise_sub(list_take(a, n), list_take(b, n))\n\n\n\nvsub synthesized: (vec_elemwise_sub:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef vsub_np (a, b, n):\n    return (a[:n]) - (b[:n])\n\n####### glued code ########\n\ndef vsub_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return vsub_np(a, b, n)\n\nSynthesis took 2.0555264949798584 seconds\n",
        "stderr": ""
    },
    "dsp-wvec": {
        "elapsed_time": 2.267546463001054,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %m.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %m, i32* %m.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %m.addr, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv = sext i32 %i5 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i6 = load i32, i32* %call, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i7 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i8 = load i32, i32* %call2, align 4\n  %add = add nsw i32 %mul, %i8\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i9 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i9, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a agg.result b i m n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a agg.result b i m n ref.tmp))) (wvec_ps:Bool a b m n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) m n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a agg.result b i m n ref.tmp)) (wvec_inv0:Bool a (list_append:List List Int agg.result (Add:Int (Mul:Int m (list_get:Int a i)) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) m n (Add:Int (Mul:Int m (list_get:Int a i)) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a agg.result b i m n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (wvec_inv0:Bool a agg.result b i m n ref.tmp))) (wvec_ps:Bool a b m n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef wvec_inv0(a, agg.result, b, i, m, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_add(vec_scalar_mul(m, list_take(a, i)), list_take(b, i))\n\n\n\ndef wvec_ps(a, b, m, n, wvec_rv)\nwvec_rv == vec_elemwise_add(vec_scalar_mul(m, list_take(a, n)), list_take(b, n))\n\n\n\nwvec synthesized: (vec_elemwise_add:List Int (vec_scalar_mul:List Int m (list_take:List Int a n)) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef wvec_np (a, b, m, n):\n    return ((m) * (a[:n])) + (b[:n])\n\n####### glued code ########\n\ndef wvec_np_glued (a, b, m, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return wvec_np(a, b, m, n)\n\nSynthesis took 2.087578773498535 seconds\n",
        "stderr": ""
    },
    "dsp-matsub": {
        "elapsed_time": 10.450872512001297,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont10\nname: for.inc11<latch>\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont10', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc11']\nfound loop: header: for.cond1, body: ['for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %m.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %m, i32* %m.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %m.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end13\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %n.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %matA, i64 %conv) #11\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %i, align 4\n  %conv6 = sext i32 %i9 to i64\n  %call7 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %matB, i64 %conv6) #11\n  %i10 = load i32, i32* %j, align 4\n  %conv8 = sext i32 %i10 to i64\n  %call9 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call7, i64 %conv8) #11\n  %i11 = load i32, i32* %call9, align 4\n  %sub = sub nsw i32 %i8, %i11\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i12 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i12, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont10\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc11\n  %i13 = load i32, i32* %i, align 4\n  %inc12 = add nsw i32 %i13, 1\n  store i32 %inc12, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec))) (matsub_ps:Bool matA matB m n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool m (Lit:Int 1)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) m matA matB n (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i m) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matsub_inv1:Bool (Lit:Int 0) m matA matB n ref.tmp (list_empty:List Int ) agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j n) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matsub_inv1:Bool j m matA matB n ref.tmp row_vec agg.result i)) (matsub_inv1:Bool (Add:Int j (Lit:Int 1)) m matA matB n (Sub:Int (list_get:Int (matrix_get:List Int matA i) j) (list_get:Int (matrix_get:List Int matB i) j)) (list_append:List List Int row_vec (Sub:Int (list_get:Int (matrix_get:List Int matA i) j) (list_get:Int (matrix_get:List Int matB i) j))) agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j n)) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (matsub_inv1:Bool j m matA matB n ref.tmp row_vec agg.result i)) (matsub_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j m matA matB n ref.tmp row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (matrix_length:Int matB) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (Ge:Bool (list_length:Int (matrix_get:List Int matB (Lit:Int 0))) n)) (matsub_inv0:Bool agg.result i j m matA matB n ref.tmp row_vec))) (matsub_ps:Bool matA matB m n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matsub_inv0(agg.result, i, j, m, matA, matB, n, ref.tmp, row_vec)\ni >= 0 and i <= m and agg.result == matrix_elemwise_sub(matrix_col_slice(matrix_take(matA, i), 0, n), matrix_col_slice(matrix_take(matB, i), 0, n))\n\n\n\ndef matsub_inv1(j, m, matA, matB, n, ref.tmp, row_vec, agg.result, i)\ni >= 0 and i < m and j >= 0 and j <= n and row_vec == vec_elemwise_sub(list_take(matrix_get(matA, i), j), list_take(matrix_get(matB, i), j)) and agg.result == matrix_elemwise_sub(matrix_col_slice(matrix_take(matA, i), 0, n), matrix_col_slice(matrix_take(matB, i), 0, n))\n\n\n\ndef matsub_ps(matA, matB, m, n, matsub_rv)\nmatsub_rv == matrix_elemwise_sub(matrix_col_slice(matrix_take(matA, m), 0, n), matrix_col_slice(matrix_take(matB, m), 0, n))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmatsub synthesized: (matrix_elemwise_sub:List Int (matrix_col_slice:List Int (matrix_take:List Int matA m) (Lit:Int 0) n) (matrix_col_slice:List Int (matrix_take:List Int matB m) (Lit:Int 0) n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matsub_np (matA, matB, m, n):\n    return (matA[:m][:, 0:n]) - (matB[:m][:, 0:n])\n\n####### glued code ########\n\ndef matsub_np_glued (matA, matB, m, n):\n    matA = np.array(matA).astype(np.int32)\n    matB = np.array(matB).astype(np.int32)\n    return matsub_np(matA, matB, m, n)\n\nSynthesis took 10.20967411994934 seconds\n",
        "stderr": ""
    },
    "dsp-matinit": {
        "elapsed_time": 0.3172525929985568,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/dsp/matinit_.cc:  tenspiler/c2taco/cpp/for_synthesis/dsp/matinit_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> matinit(int M, int N, int val) {\n    vector<vector<int>> A;\n    for (int i = 0; i < M; ++i) {\n        vector<int> row;\n        for (int j = 0; j < N; ++j) {\n            row.push_back(val);\n        }\n        A.push_back(row);\n    }\n    return A;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/dsp/matinit_.cc:  tenspiler/c2taco/cpp/for_synthesis/dsp/matinit_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> matinit(int M, int N, int val) {\n    vector<vector<int>> A;\n    for (int i = 0; i < M; ++i) {\n        vector<int> row;\n        for (int j = 0; j < N; ++j) {\n            row.push_back(val);\n        }\n        A.push_back(row);\n    }\n    return A;\n}\nPush statement: row.push_back(val)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb10\nname: for.end\nname: invoke.cont4\nname: for.inc5<latch>\nname: bb9\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb9\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb10', 'for.end', 'invoke.cont4', 'bb9', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc5']\nfound loop: header: for.cond1, body: ['bb9', 'for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %M.addr = alloca i32, align 4\n  %N.addr = alloca i32, align 4\n  %val.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %M, i32* %M.addr, align 4\n  store i32 %N, i32* %N.addr, align 4\n  store i32 %val, i32* %val.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/dsp/matinit_driver.py\", line 16, in <module>\n    matinit(M, N, val)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 971, in get_outer_loop_inv\n    type_expr_tree = build_type_expression_tree(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 461, in build_type_expression_tree\n    return helper(compute_node, target_type)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 336, in helper\n    if node.type == \"assignment_expression\":\nAttributeError: 'NoneType' object has no attribute 'type'\n"
    },
    "dsp-vfill": {
        "elapsed_time": 0.270955388999937,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/dsp/vfill_.cc:  tenspiler/c2taco/cpp/for_synthesis/dsp/vfill_.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<int> vfill(vector<int> arr, int v) {\n    vector<int> S;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        S.push_back(v);\n    }\n    return S;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/dsp/vfill_.cc:  tenspiler/c2taco/cpp/for_synthesis/dsp/vfill_.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<int> vfill(vector<int> arr, int v) {\n    vector<int> S;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        S.push_back(v);\n    }\n    return S;\n}\nPush statement: S.push_back(v)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %v.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %n = alloca i32, align 4\n  %i = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %v, i32* %v.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %arr) #10\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %n, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/dsp/vfill_driver.py\", line 15, in <module>\n    vfill(arr, v)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1138, in inv_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 971, in get_outer_loop_inv\n    type_expr_tree = build_type_expression_tree(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 461, in build_type_expression_tree\n    return helper(compute_node, target_type)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 336, in helper\n    if node.type == \"assignment_expression\":\nAttributeError: 'NoneType' object has no attribute 'type'\n"
    },
    "dspstone-n_real_updates": {
        "elapsed_time": 2.278191160999995,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %curr = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %N.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %C, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %A, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %i8 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i8 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %B, i64 %conv3) #11\n  %i9 = load i32, i32* %call4, align 4\n  %mul = mul nsw i32 %i7, %i9\n  %add = add nsw i32 %i5, %mul\n  store i32 %add, i32* %curr, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %curr)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N agg.result curr i)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N agg.result curr i))) (n_real_updates_ps:Bool N A B C agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool N (Lit:Int 1)) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N agg.result curr i)) (n_real_updates_inv0:Bool A B C N (list_append:List List Int agg.result (Add:Int (list_get:Int C i) (Mul:Int (list_get:Int A i) (list_get:Int B i)))) (Add:Int (list_get:Int C i) (Mul:Int (list_get:Int A i) (list_get:Int B i))) (Add:Int i (Lit:Int 1)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N agg.result curr i)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (list_length:Int A) N)) (Ge:Bool (list_length:Int B) N)) (Ge:Bool (list_length:Int C) N)) (n_real_updates_inv0:Bool A B C N agg.result curr i))) (n_real_updates_ps:Bool N A B C agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef n_real_updates_inv0(A, B, C, N, agg.result, curr, i)\ni >= 0 and i <= N and agg.result == vec_elemwise_add(list_take(C, i), vec_elemwise_mul(list_take(B, i), list_take(A, i)))\n\n\n\ndef n_real_updates_ps(N, A, B, C, n_real_updates_rv)\nn_real_updates_rv == vec_elemwise_add(vec_elemwise_mul(list_take(A, N), list_take(B, N)), list_take(C, N))\n\n\n\nn_real_updates synthesized: (vec_elemwise_add:List Int (vec_elemwise_mul:List Int (list_take:List Int A N) (list_take:List Int B N)) (list_take:List Int C N))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef n_real_updates_np (N, A, B, C):\n    return ((A[:N]) * (B[:N])) + (C[:N])\n\n####### glued code ########\n\ndef n_real_updates_np_glued (N, A, B, C):\n    A = np.array(A).astype(np.int32)\n    B = np.array(B).astype(np.int32)\n    C = np.array(C).astype(np.int32)\n    return n_real_updates_np(N, A, B, C)\n\nSynthesis took 2.097571849822998 seconds\n",
        "stderr": ""
    },
    "dspstone-mat1x3": {
        "elapsed_time": 4.328239374999612,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont\nname: for.inc8<latch>\nname: for.body3\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont', 'for.body3', 'for.inc'], exits: ['for.cond'], latches: ['for.inc8']\nfound loop: header: for.cond1, body: ['for.body3'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %f = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %N.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end10\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %f, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %f, align 4\n  %i5 = load i32, i32* %N.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %h, i64 %conv) #11\n  %i7 = load i32, i32* %f, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %f, align 4\n  %conv6 = sext i32 %i9 to i64\n  %call7 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %x, i64 %conv6) #11\n  %i10 = load i32, i32* %call7, align 4\n  %mul = mul nsw i32 %i8, %i10\n  %i11 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i11, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i12 = load i32, i32* %f, align 4\n  %inc = add nsw i32 %i12, 1\n  store i32 %inc, i32* %f, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %sum)\n  br label %invoke.cont\n  br label %for.inc8\n  %i13 = load i32, i32* %i, align 4\n  %inc9 = add nsw i32 %i13, 1\n  store i32 %inc9, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x))) (mat1x3_ps:Bool N h x agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool N (Lit:Int 1)) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N (list_empty:List Int ) (Lit:Int 0) h (Lit:Int 0) (Lit:Int 0) x)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x)) (mat1x3_inv1:Bool N (Lit:Int 0) h (Lit:Int 0) x agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool f N) (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x)) (mat1x3_inv1:Bool N f h sum x agg.result i)) (mat1x3_inv1:Bool N (Add:Int f (Lit:Int 1)) h (Add:Int sum (Mul:Int (list_get:Int (matrix_get:List Int h i) f) (list_get:Int x f))) x agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool f N)) (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x)) (mat1x3_inv1:Bool N f h sum x agg.result i)) (mat1x3_inv0:Bool N (list_append:List List Int agg.result sum) f h (Add:Int i (Lit:Int 1)) sum x)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i N)) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (Ge:Bool (matrix_length:Int h) N)) (Ge:Bool (list_length:Int (matrix_get:List Int h (Lit:Int 0))) N)) (Ge:Bool (list_length:Int x) N)) (mat1x3_inv0:Bool N agg.result f h i sum x))) (mat1x3_ps:Bool N h x agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef mat1x3_inv0(N, agg.result, f, h, i, sum, x)\ni >= 0 and i <= N and agg.result == matrix_vec_mul(matrix_col_slice(matrix_take(h, i), 0, N), list_take(x, N))\n\n\n\ndef mat1x3_inv1(N, f, h, sum, x, agg.result, i)\ni >= 0 and i < N and f >= 0 and f <= N and sum == reduce_sum(vec_elemwise_mul(list_take(matrix_get(h, i), f), list_take(x, f))) and agg.result == matrix_vec_mul(matrix_col_slice(matrix_take(h, i), 0, N), list_take(x, N))\n\n\n\ndef mat1x3_ps(N, h, x, mat1x3_rv)\nmat1x3_rv == matrix_vec_mul(matrix_col_slice(matrix_take(h, N), 0, N), list_take(x, N))\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndef VECTOR_OUTER_LOOP_INDEX()\nFalse\n\n\n\nmat1x3 synthesized: (matrix_vec_mul:List Int (matrix_col_slice:List Int (matrix_take:List Int h N) (Lit:Int 0) N) (list_take:List Int x N))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef mat1x3_np (N, h, x):\n    return np.matmul(h[:N][:, 0:N], x[:N])\n\n####### glued code ########\n\ndef mat1x3_np_glued (N, h, x):\n    h = np.array(h).astype(np.int32)\n    x = np.array(x).astype(np.int32)\n    return mat1x3_np(N, h, x)\n\nSynthesis took 4.139803171157837 seconds\n",
        "stderr": ""
    },
    "dspstone-pin_down": {
        "elapsed_time": 4.379182780998235,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/dspstone/pin_down_.cc:  tenspiler/c2taco/cpp/for_synthesis/dspstone/pin_down_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> pin_down(int N) {\n    vector<int> vec;\n    for (int i = 0; i < N; ++i) {\n        vec.push_back(1);\n    }\n    return vec;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/dspstone/pin_down_.cc:  tenspiler/c2taco/cpp/for_synthesis/dspstone/pin_down_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> pin_down(int N) {\n    vector<int> vec;\n    for (int i = 0; i < N; ++i) {\n        vec.push_back(1);\n    }\n    return vec;\n}\nPush statement: vec.push_back(1)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %N.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %bb, label %bb5\n  br label %for.body\n  br label %for.end\n  store i32 1, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i4 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i4, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %bb6, label %bb7\n  br label %nrvo.skipdtor\n  br label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp))) (pin_down_ps:Bool N agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (Ge:Bool N (Lit:Int 1)) (pin_down_inv0:Bool N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp)) (pin_down_inv0:Bool N (list_append:List List Int agg.result (Lit:Int 1)) (Add:Int i (Lit:Int 1)) (Lit:Int 1))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp))) (pin_down_ps:Bool N agg.result))]\nStrict grammar with list bound 2 failed\nTrying relaxed grammar...\nasserts: [(Implies:Bool (Ge:Bool N (Lit:Int 1)) (pin_down_inv0:Bool N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp)) (pin_down_inv0:Bool N (list_append:List List Int agg.result (Lit:Int 1)) (Add:Int i (Lit:Int 1)) (Lit:Int 1))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (pin_down_inv0:Bool N agg.result i ref.tmp))) (pin_down_ps:Bool N agg.result))]\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 51, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/dspstone/pin_down_driver.py\", line 16, in <module>\n    run_synthesis_algorithm(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 139, in run_synthesis_algorithm\n    raise e\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 126, in run_synthesis_algorithm\n    run_synthesis_with_bound(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 67, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n"
    },
    "makespeare-sum_of_squares": {
        "elapsed_time": 2.1931367049983237,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_of_squares_inv0:Bool arr i n sum)) (sum_of_squares_ps:Bool arr n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_of_squares_inv0:Bool arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_of_squares_inv0:Bool arr i n sum)) (sum_of_squares_inv0:Bool arr (Add:Int i (Lit:Int 1)) n (Add:Int sum (Mul:Int (list_get:Int arr i) (list_get:Int arr i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_of_squares_inv0:Bool arr i n sum)) (sum_of_squares_ps:Bool arr n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef sum_of_squares_inv0(arr, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(vec_elemwise_mul(list_take(arr, i), list_take(arr, i)))\n\n\n\ndef sum_of_squares_ps(arr, n, sum_of_squares_rv)\nsum_of_squares_rv == reduce_sum(vec_elemwise_mul(list_take(arr, n), list_take(arr, n)))\n\n\n\nsum_of_squares synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int arr n) (list_take:List Int arr n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef sum_of_squares_np (arr, n):\n    return np.sum((arr[:n]) * (arr[:n]))\n\n####### glued code ########\n\ndef sum_of_squares_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return sum_of_squares_np(arr, n)\n\nSynthesis took 2.023195743560791 seconds\n",
        "stderr": ""
    },
    "mathfu-len": {
        "elapsed_time": 2.19706223600042,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %l = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %l, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %l, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %l, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %l, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_inv0:Bool arr i l n)) (len_ps:Bool arr n l))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_inv0:Bool arr (Lit:Int 0) (Lit:Int 0) n)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_inv0:Bool arr i l n)) (len_inv0:Bool arr (Add:Int i (Lit:Int 1)) (Add:Int l (Mul:Int (list_get:Int arr i) (list_get:Int arr i))) n)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_inv0:Bool arr i l n)) (len_ps:Bool arr n l))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef len_inv0(arr, i, l, n)\ni >= 0 and i <= n and l == reduce_sum(vec_elemwise_mul(list_take(arr, i), list_take(arr, i)))\n\n\n\ndef len_ps(arr, n, len_rv)\nlen_rv == reduce_sum(vec_elemwise_mul(list_take(arr, n), list_take(arr, n)))\n\n\n\nlen synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int arr n) (list_take:List Int arr n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef len_np (arr, n):\n    return np.sum((arr[:n]) * (arr[:n]))\n\n####### glued code ########\n\ndef len_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return len_np(arr, n)\n\nSynthesis took 2.023960828781128 seconds\n",
        "stderr": ""
    },
    "mathfu-diveq_sca": {
        "elapsed_time": 2.2153135239987023,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %b.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %b, i32* %b.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %b.addr, align 4\n  %div = sdiv i32 %i5, %i6\n  store i32 %div, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a agg.result b i n ref.tmp))) (diveq_sca_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a agg.result b i n ref.tmp)) (diveq_sca_inv0:Bool a (list_append:List List Int agg.result (Div:Int (list_get:Int a i) b)) b (Add:Int i (Lit:Int 1)) n (Div:Int (list_get:Int a i) b))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (diveq_sca_inv0:Bool a agg.result b i n ref.tmp))) (diveq_sca_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef diveq_sca_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_scalar_div(b, list_take(a, i))\n\n\n\ndef diveq_sca_ps(a, b, n, diveq_sca_rv)\nlist_eq(diveq_sca_rv, vec_scalar_div(b, list_take(a, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef diveq_sca_np (a, b, n):\n    return (a[:n]) // (b)\n\n####### glued code ########\n\ndef diveq_sca_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    return diveq_sca_np(a, b, n)\n\nSynthesis took 2.0405831336975098 seconds\n",
        "stderr": ""
    },
    "mathfu-subeq_sca": {
        "elapsed_time": 2.2355744630003755,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %b.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %b, i32* %b.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %b.addr, align 4\n  %sub = sub nsw i32 %i5, %i6\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a agg.result b i n ref.tmp))) (subeq_sca_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a agg.result b i n ref.tmp)) (subeq_sca_inv0:Bool a (list_append:List List Int agg.result (Sub:Int (list_get:Int a i) b)) b (Add:Int i (Lit:Int 1)) n (Sub:Int (list_get:Int a i) b))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (subeq_sca_inv0:Bool a agg.result b i n ref.tmp))) (subeq_sca_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef subeq_sca_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_scalar_sub(b, list_take(a, i))\n\n\n\ndef subeq_sca_ps(a, b, n, subeq_sca_rv)\nlist_eq(subeq_sca_rv, vec_scalar_sub(b, list_take(a, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef subeq_sca_np (a, b, n):\n    return (a[:n]) - (b)\n\n####### glued code ########\n\ndef subeq_sca_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    return subeq_sca_np(a, b, n)\n\nSynthesis took 2.0586018562316895 seconds\n",
        "stderr": ""
    },
    "mathfu-len_sq": {
        "elapsed_time": 2.19294919999993,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %l = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %l, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %l, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %l, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %l, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_sq_inv0:Bool arr i l n)) (len_sq_ps:Bool arr n l))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_sq_inv0:Bool arr (Lit:Int 0) (Lit:Int 0) n)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_sq_inv0:Bool arr i l n)) (len_sq_inv0:Bool arr (Add:Int i (Lit:Int 1)) (Add:Int l (Mul:Int (list_get:Int arr i) (list_get:Int arr i))) n)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (len_sq_inv0:Bool arr i l n)) (len_sq_ps:Bool arr n l))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef len_sq_inv0(arr, i, l, n)\ni >= 0 and i <= n and l == reduce_sum(vec_elemwise_mul(list_take(arr, i), list_take(arr, i)))\n\n\n\ndef len_sq_ps(arr, n, len_sq_rv)\nlen_sq_rv == reduce_sum(vec_elemwise_mul(list_take(arr, n), list_take(arr, n)))\n\n\n\nlen_sq synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int arr n) (list_take:List Int arr n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef len_sq_np (arr, n):\n    return np.sum((arr[:n]) * (arr[:n]))\n\n####### glued code ########\n\ndef len_sq_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return len_sq_np(arr, n)\n\nSynthesis took 2.022125005722046 seconds\n",
        "stderr": ""
    },
    "mathfu-muleq_sca": {
        "elapsed_time": 2.2188188250001986,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %b.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %b, i32* %b.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %b.addr, align 4\n  %mul = mul nsw i32 %i5, %i6\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a agg.result b i n ref.tmp))) (muleq_sca_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a agg.result b i n ref.tmp)) (muleq_sca_inv0:Bool a (list_append:List List Int agg.result (Mul:Int (list_get:Int a i) b)) b (Add:Int i (Lit:Int 1)) n (Mul:Int (list_get:Int a i) b))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (muleq_sca_inv0:Bool a agg.result b i n ref.tmp))) (muleq_sca_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef muleq_sca_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_scalar_mul(b, list_take(a, i))\n\n\n\ndef muleq_sca_ps(a, b, n, muleq_sca_rv)\nlist_eq(muleq_sca_rv, vec_scalar_mul(b, list_take(a, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef muleq_sca_np (a, b, n):\n    return (b) * (a[:n])\n\n####### glued code ########\n\ndef muleq_sca_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    return muleq_sca_np(a, b, n)\n\nSynthesis took 2.0426249504089355 seconds\n",
        "stderr": ""
    },
    "mathfu-matmul_sca": {
        "elapsed_time": 4.40454150900041,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont6\nname: for.inc7<latch>\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont6', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc7']\nfound loop: header: for.cond1, body: ['for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %val.addr = alloca i32, align 4\n  %m.addr = alloca i32, align 4\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %val, i32* %val.addr, align 4\n  store i32 %m, i32* %m.addr, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %m.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end9\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %n.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %i, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %matA, i64 %conv) #11\n  %i7 = load i32, i32* %j, align 4\n  %conv4 = sext i32 %i7 to i64\n  %call5 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call, i64 %conv4) #11\n  %i8 = load i32, i32* %call5, align 4\n  %i9 = load i32, i32* %val.addr, align 4\n  %mul = mul nsw i32 %i8, %i9\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont6\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc7\n  %i11 = load i32, i32* %i, align 4\n  %inc8 = add nsw i32 %i11, 1\n  store i32 %inc8, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val))) (matmul_sca_ps:Bool matA val m n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool m (Lit:Int 1)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) m matA n (Lit:Int 0) (list_empty:List Int ) val)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i m) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val)) (matmul_sca_inv1:Bool (Lit:Int 0) m matA n ref.tmp (list_empty:List Int ) val agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j n) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val)) (matmul_sca_inv1:Bool j m matA n ref.tmp row_vec val agg.result i)) (matmul_sca_inv1:Bool (Add:Int j (Lit:Int 1)) m matA n (Mul:Int (list_get:Int (matrix_get:List Int matA i) j) val) (list_append:List List Int row_vec (Mul:Int (list_get:Int (matrix_get:List Int matA i) j) val)) val agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j n)) (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val)) (matmul_sca_inv1:Bool j m matA n ref.tmp row_vec val agg.result i)) (matmul_sca_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j m matA n ref.tmp row_vec val)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i m)) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i m))) (Ge:Bool m (Lit:Int 1))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (matrix_length:Int matA) m)) (Ge:Bool (list_length:Int (matrix_get:List Int matA (Lit:Int 0))) n)) (matmul_sca_inv0:Bool agg.result i j m matA n ref.tmp row_vec val))) (matmul_sca_ps:Bool matA val m n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matmul_sca_inv0(agg.result, i, j, m, matA, n, ref.tmp, row_vec, val)\ni >= 0 and i <= m and agg.result == matrix_scalar_mul(val, matrix_col_slice(matrix_take(matA, i), 0, n))\n\n\n\ndef matmul_sca_inv1(j, m, matA, n, ref.tmp, row_vec, val, agg.result, i)\ni >= 0 and i < m and j >= 0 and j <= n and row_vec == vec_scalar_mul(val, list_take(matrix_get(matA, i), j)) and agg.result == matrix_scalar_mul(val, matrix_col_slice(matrix_take(matA, i), 0, n))\n\n\n\ndef matmul_sca_ps(matA, val, m, n, matmul_sca_rv)\nmatmul_sca_rv == matrix_scalar_mul(val, matrix_col_slice(matrix_take(matA, m), 0, n))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmatmul_sca synthesized: (matrix_scalar_mul:List Int val (matrix_col_slice:List Int (matrix_take:List Int matA m) (Lit:Int 0) n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matmul_sca_np (matA, val, m, n):\n    return (val) * (matA[:m][:, 0:n])\n\n####### glued code ########\n\ndef matmul_sca_np_glued (matA, val, m, n):\n    matA = np.array(matA).astype(np.int32)\n    return matmul_sca_np(matA, val, m, n)\n\nSynthesis took 4.191241025924683 seconds\n",
        "stderr": ""
    },
    "mathfu-diveq": {
        "elapsed_time": 2.217966599999272,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %div = sdiv i32 %i5, %i7\n  store i32 %div, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a agg.result b i n ref.tmp))) (diveq_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a agg.result b i n ref.tmp)) (diveq_inv0:Bool a (list_append:List List Int agg.result (Div:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Div:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (diveq_inv0:Bool a agg.result b i n ref.tmp))) (diveq_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef diveq_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_div(list_take(a, i), list_take(b, i))\n\n\n\ndef diveq_ps(a, b, n, diveq_rv)\ndiveq_rv == vec_elemwise_div(list_take(a, n), list_take(b, n))\n\n\n\ndiveq synthesized: (vec_elemwise_div:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef diveq_np (a, b, n):\n    return (a[:n]) // (b[:n])\n\n####### glued code ########\n\ndef diveq_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return diveq_np(a, b, n)\n\nSynthesis took 2.040992498397827 seconds\n",
        "stderr": ""
    },
    "mathfu-muleq": {
        "elapsed_time": 2.275189109001076,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i5, %i7\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a agg.result b i n ref.tmp))) (muleq_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a agg.result b i n ref.tmp)) (muleq_inv0:Bool a (list_append:List List Int agg.result (Mul:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Mul:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (muleq_inv0:Bool a agg.result b i n ref.tmp))) (muleq_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef muleq_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_mul(list_take(a, i), list_take(b, i))\n\n\n\ndef muleq_ps(a, b, n, muleq_rv)\nmuleq_rv == vec_elemwise_mul(list_take(a, n), list_take(b, n))\n\n\n\nmuleq synthesized: (vec_elemwise_mul:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef muleq_np (a, b, n):\n    return (a[:n]) * (b[:n])\n\n####### glued code ########\n\ndef muleq_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return muleq_np(a, b, n)\n\nSynthesis took 2.082193613052368 seconds\n",
        "stderr": ""
    },
    "mathfu-negate": {
        "elapsed_time": 2.2333243869998114,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %sub = sub nsw i32 0, %i5\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool agg.result arr i n ref.tmp))) (negate_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool agg.result arr i n ref.tmp)) (negate_inv0:Bool (list_append:List List Int agg.result (Sub:Int (Lit:Int 0) (list_get:Int arr i))) arr (Add:Int i (Lit:Int 1)) n (Sub:Int (Lit:Int 0) (list_get:Int arr i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (negate_inv0:Bool agg.result arr i n ref.tmp))) (negate_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef negate_inv0(agg.result, arr, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == scalar_vec_sub(0, list_take(arr, i))\n\n\n\ndef negate_ps(arr, n, negate_rv)\nlist_eq(negate_rv, scalar_vec_sub(0, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef negate_np (arr, n):\n    return (0) - (arr[:n])\n\n####### glued code ########\n\ndef negate_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return negate_np(arr, n)\n\nSynthesis took 2.0529356002807617 seconds\n",
        "stderr": ""
    },
    "mathfu-pluseq": {
        "elapsed_time": 2.2542328649997216,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %add = add nsw i32 %i5, %i7\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a agg.result b i n ref.tmp))) (pluseq_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a agg.result b i n ref.tmp)) (pluseq_inv0:Bool a (list_append:List List Int agg.result (Add:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Add:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (pluseq_inv0:Bool a agg.result b i n ref.tmp))) (pluseq_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef pluseq_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_add(list_take(a, i), list_take(b, i))\n\n\n\ndef pluseq_ps(a, b, n, pluseq_rv)\npluseq_rv == vec_elemwise_add(list_take(a, n), list_take(b, n))\n\n\n\npluseq synthesized: (vec_elemwise_add:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef pluseq_np (a, b, n):\n    return (a[:n]) + (b[:n])\n\n####### glued code ########\n\ndef pluseq_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return pluseq_np(a, b, n)\n\nSynthesis took 2.076056957244873 seconds\n",
        "stderr": ""
    },
    "mathfu-subeq": {
        "elapsed_time": 2.2351464020011917,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %a, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %b, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %sub = sub nsw i32 %i5, %i7\n  store i32 %sub, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a agg.result b i n ref.tmp))) (subeq_ps:Bool a b n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a (list_empty:List Int ) b (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a agg.result b i n ref.tmp)) (subeq_inv0:Bool a (list_append:List List Int agg.result (Sub:Int (list_get:Int a i) (list_get:Int b i))) b (Add:Int i (Lit:Int 1)) n (Sub:Int (list_get:Int a i) (list_get:Int b i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a agg.result b i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int a) n)) (Ge:Bool (list_length:Int b) n)) (subeq_inv0:Bool a agg.result b i n ref.tmp))) (subeq_ps:Bool a b n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef subeq_inv0(a, agg.result, b, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_sub(list_take(a, i), list_take(b, i))\n\n\n\ndef subeq_ps(a, b, n, subeq_rv)\nsubeq_rv == vec_elemwise_sub(list_take(a, n), list_take(b, n))\n\n\n\nsubeq synthesized: (vec_elemwise_sub:List Int (list_take:List Int a n) (list_take:List Int b n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef subeq_np (a, b, n):\n    return (a[:n]) - (b[:n])\n\n####### glued code ########\n\ndef subeq_np_glued (a, b, n):\n    a = np.array(a).astype(np.int32)\n    b = np.array(b).astype(np.int32)\n    return subeq_np(a, b, n)\n\nSynthesis took 2.059298515319824 seconds\n",
        "stderr": ""
    },
    "mathfu-lerp": {
        "elapsed_time": 0.3000728339993657,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/mathfu/lerp_.cc:  tenspiler/c2taco/cpp/for_synthesis/mathfu/lerp_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> lerp(int N, vector<int> a, vector<int> b, int t) {\n    vector<int> result;\n    for (int i = 0; i < N; ++i) {\n        int interp = t * a[i] + (1 - t) * b[i];\n        result.push_back(interp);\n    }\n    return result;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/mathfu/lerp_.cc:  tenspiler/c2taco/cpp/for_synthesis/mathfu/lerp_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> lerp(int N, vector<int> a, vector<int> b, int t) {\n    vector<int> result;\n    for (int i = 0; i < N; ++i) {\n        int interp = t * a[i] + (1 - t) * b[i];\n        result.push_back(interp);\n    }\n    return result;\n}\nPush statement: result.push_back(interp)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %t.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %interp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i32 %t, i32* %t.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/mathfu/lerp_driver.py\", line 19, in <module>\n    lerp(N, a, b, t)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1138, in inv_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 533, in preorder_traversal_with_objs\n    right_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 530, in preorder_traversal_with_objs\n    left_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 565, in preorder_traversal_with_objs\n    function = getattr(tenspiler_common, call_obj.src.name())\nAttributeError: 'NoneType' object has no attribute 'src'\n"
    },
    "simpl_array-array_inc": {
        "elapsed_time": 2.225667873999555,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %add = add nsw i32 %i5, 1\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool agg.result arr i n ref.tmp))) (array_inc_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool agg.result arr i n ref.tmp)) (array_inc_inv0:Bool (list_append:List List Int agg.result (Add:Int (list_get:Int arr i) (Lit:Int 1))) arr (Add:Int i (Lit:Int 1)) n (Add:Int (list_get:Int arr i) (Lit:Int 1)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (array_inc_inv0:Bool agg.result arr i n ref.tmp))) (array_inc_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef array_inc_inv0(agg.result, arr, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_scalar_add(1, list_take(arr, i))\n\n\n\ndef array_inc_ps(arr, n, array_inc_rv)\nlist_eq(array_inc_rv, vec_scalar_add(1, list_take(arr, n)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef array_inc_np (arr, n):\n    return (1) + (arr[:n])\n\n####### glued code ########\n\ndef array_inc_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return array_inc_np(arr, n)\n\nSynthesis took 2.0508644580841064 seconds\n",
        "stderr": ""
    },
    "simpl_array-fourth_in_place": {
        "elapsed_time": 2.2380798989997857,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %sq = alloca i32, align 4\n  %fourth = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i5, %i7\n  store i32 %mul, i32* %sq, align 4\n  %i8 = load i32, i32* %sq, align 4\n  %i9 = load i32, i32* %sq, align 4\n  %mul3 = mul nsw i32 %i8, %i9\n  store i32 %mul3, i32* %fourth, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %fourth)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool agg.result arr fourth i n sq)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool agg.result arr fourth i n sq))) (fourth_in_place_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool agg.result arr fourth i n sq)) (fourth_in_place_inv0:Bool (list_append:List List Int agg.result (Mul:Int (Mul:Int (list_get:Int arr i) (list_get:Int arr i)) (Mul:Int (list_get:Int arr i) (list_get:Int arr i)))) arr (Mul:Int (Mul:Int (list_get:Int arr i) (list_get:Int arr i)) (Mul:Int (list_get:Int arr i) (list_get:Int arr i))) (Add:Int i (Lit:Int 1)) n (Mul:Int (list_get:Int arr i) (list_get:Int arr i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool agg.result arr fourth i n sq)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (fourth_in_place_inv0:Bool agg.result arr fourth i n sq))) (fourth_in_place_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef fourth_in_place_inv0(agg.result, arr, fourth, i, n, sq)\ni >= 0 and i <= n and agg.result == vec_elemwise_mul(vec_elemwise_mul(list_take(arr, i), list_take(arr, i)), vec_elemwise_mul(list_take(arr, i), list_take(arr, i)))\n\n\n\ndef fourth_in_place_ps(arr, n, fourth_in_place_rv)\nfourth_in_place_rv == vec_elemwise_mul(vec_elemwise_mul(list_take(arr, n), list_take(arr, n)), vec_elemwise_mul(list_take(arr, n), list_take(arr, n)))\n\n\n\nfourth_in_place synthesized: (vec_elemwise_mul:List Int (vec_elemwise_mul:List Int (list_take:List Int arr n) (list_take:List Int arr n)) (vec_elemwise_mul:List Int (list_take:List Int arr n) (list_take:List Int arr n)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef fourth_in_place_np (arr, n):\n    return ((arr[:n]) * (arr[:n])) * ((arr[:n]) * (arr[:n]))\n\n####### glued code ########\n\ndef fourth_in_place_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return fourth_in_place_np(arr, n)\n\nSynthesis took 2.0532639026641846 seconds\n",
        "stderr": ""
    },
    "simpl_array-sum_elts": {
        "elapsed_time": 2.1881118070014054,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i5, %i4\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i7 = load i32, i32* %sum, align 4\n  ret i32 %i7\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_elts_inv0:Bool arr i n sum)) (sum_elts_ps:Bool arr n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_elts_inv0:Bool arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_elts_inv0:Bool arr i n sum)) (sum_elts_inv0:Bool arr (Add:Int i (Lit:Int 1)) n (Add:Int sum (list_get:Int arr i)))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (sum_elts_inv0:Bool arr i n sum)) (sum_elts_ps:Bool arr n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef sum_elts_inv0(arr, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(list_take(arr, i))\n\n\n\ndef sum_elts_ps(arr, n, sum_elts_rv)\nsum_elts_rv == reduce_sum(list_take(arr, n))\n\n\n\nsum_elts synthesized: (reduce_sum:Int (list_take:List Int arr n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef sum_elts_np (arr, n):\n    return np.sum(arr[:n])\n\n####### glued code ########\n\ndef sum_elts_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return sum_elts_np(arr, n)\n\nSynthesis took 2.0186831951141357 seconds\n",
        "stderr": ""
    },
    "simpl_array-cube_in_place": {
        "elapsed_time": 2.2626970170003915,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %n.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %n, i32* %n.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i5, %i7\n  %i8 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i8 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv3) #11\n  %i9 = load i32, i32* %call4, align 4\n  %mul5 = mul nsw i32 %mul, %i9\n  store i32 %mul5, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool agg.result arr i n ref.tmp))) (cube_in_place_ps:Bool arr n agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool (list_empty:List Int ) arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool agg.result arr i n ref.tmp)) (cube_in_place_inv0:Bool (list_append:List List Int agg.result (Mul:Int (Mul:Int (list_get:Int arr i) (list_get:Int arr i)) (list_get:Int arr i))) arr (Add:Int i (Lit:Int 1)) n (Mul:Int (Mul:Int (list_get:Int arr i) (list_get:Int arr i)) (list_get:Int arr i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool agg.result arr i n ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i n))) (Ge:Bool n (Lit:Int 1))) (Ge:Bool (list_length:Int arr) n)) (cube_in_place_inv0:Bool agg.result arr i n ref.tmp))) (cube_in_place_ps:Bool arr n agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef cube_in_place_inv0(agg.result, arr, i, n, ref.tmp)\ni >= 0 and i <= n and agg.result == vec_elemwise_mul(list_take(arr, i), vec_elemwise_mul(list_take(arr, i), list_take(arr, i)))\n\n\n\ndef cube_in_place_ps(arr, n, cube_in_place_rv)\nlist_eq(cube_in_place_rv, vec_elemwise_mul(list_take(arr, n), vec_elemwise_mul(list_take(arr, n), list_take(arr, n))))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef cube_in_place_np (arr, n):\n    return (arr[:n]) * ((arr[:n]) * (arr[:n]))\n\n####### glued code ########\n\ndef cube_in_place_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return cube_in_place_np(arr, n)\n\nSynthesis took 2.0824484825134277 seconds\n",
        "stderr": ""
    },
    "simpl_array-array_sum": {
        "elapsed_time": 2.1907353089991375,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %n.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %n, i32* %n.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %n.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %arr, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i5, %i4\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i7 = load i32, i32* %sum, align 4\n  ret i32 %i7\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (array_sum_inv0:Bool arr i n sum)) (array_sum_ps:Bool arr n sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool n (Lit:Int 1)) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (array_sum_inv0:Bool arr (Lit:Int 0) n (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i n) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (array_sum_inv0:Bool arr i n sum)) (array_sum_inv0:Bool arr (Add:Int i (Lit:Int 1)) n (Add:Int sum (list_get:Int arr i)))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i n)) (Ge:Bool n (Lit:Int 1))) (Gt:Bool (list_length:Int arr) (Lit:Int 0))) (Ge:Bool (list_length:Int arr) n)) (array_sum_inv0:Bool arr i n sum)) (array_sum_ps:Bool arr n sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef array_sum_inv0(arr, i, n, sum)\ni >= 0 and i <= n and sum == reduce_sum(list_take(arr, i))\n\n\n\ndef array_sum_ps(arr, n, array_sum_rv)\narray_sum_rv == reduce_sum(list_take(arr, n))\n\n\n\narray_sum synthesized: (reduce_sum:Int (list_take:List Int arr n))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef array_sum_np (arr, n):\n    return np.sum(arr[:n])\n\n####### glued code ########\n\ndef array_sum_np_glued (arr, n):\n    arr = np.array(arr).astype(np.int32)\n    return array_sum_np(arr, n)\n\nSynthesis took 2.0193376541137695 seconds\n",
        "stderr": ""
    },
    "utdsp-fir_small": {
        "elapsed_time": 2.2030319790010253,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %NTAPS.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %NTAPS, i32* %NTAPS.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %NTAPS.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %coefficient, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i NTAPS)) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (fir_small_inv0:Bool NTAPS coefficient i input sum)) (fir_small_ps:Bool NTAPS input coefficient sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool NTAPS (Lit:Int 1)) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (fir_small_inv0:Bool NTAPS coefficient (Lit:Int 0) input (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i NTAPS) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (fir_small_inv0:Bool NTAPS coefficient i input sum)) (fir_small_inv0:Bool NTAPS coefficient (Add:Int i (Lit:Int 1)) input (Add:Int sum (Mul:Int (list_get:Int input i) (list_get:Int coefficient i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i NTAPS)) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (fir_small_inv0:Bool NTAPS coefficient i input sum)) (fir_small_ps:Bool NTAPS input coefficient sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef fir_small_inv0(NTAPS, coefficient, i, input, sum)\ni >= 0 and i <= NTAPS and sum == reduce_sum(vec_elemwise_mul(list_take(coefficient, i), list_take(input, i)))\n\n\n\ndef fir_small_ps(NTAPS, input, coefficient, fir_small_rv)\nfir_small_rv == reduce_sum(vec_elemwise_mul(list_take(coefficient, NTAPS), list_take(input, NTAPS)))\n\n\n\nfir_small synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int coefficient NTAPS) (list_take:List Int input NTAPS)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef fir_small_np (NTAPS, input, coefficient):\n    return np.sum((coefficient[:NTAPS]) * (input[:NTAPS]))\n\n####### glued code ########\n\ndef fir_small_np_glued (NTAPS, input, coefficient):\n    input = np.array(input).astype(np.int32)\n    coefficient = np.array(coefficient).astype(np.int32)\n    return fir_small_np(NTAPS, input, coefficient)\n\nSynthesis took 2.0290305614471436 seconds\n",
        "stderr": ""
    },
    "utdsp-lmsfir1": {
        "elapsed_time": 2.2145839709992288,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %NTAPS.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %NTAPS, i32* %NTAPS.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %NTAPS.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i5 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %coefficient, i64 %conv1) #1\n  %i6 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i4, %i6\n  %i7 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i7, %mul\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i9 = load i32, i32* %sum, align 4\n  ret i32 %i9\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i NTAPS)) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir1_inv0:Bool NTAPS coefficient i input sum)) (lmsfir1_ps:Bool NTAPS input coefficient sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool NTAPS (Lit:Int 1)) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir1_inv0:Bool NTAPS coefficient (Lit:Int 0) input (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i NTAPS) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir1_inv0:Bool NTAPS coefficient i input sum)) (lmsfir1_inv0:Bool NTAPS coefficient (Add:Int i (Lit:Int 1)) input (Add:Int sum (Mul:Int (list_get:Int input i) (list_get:Int coefficient i))))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i NTAPS)) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir1_inv0:Bool NTAPS coefficient i input sum)) (lmsfir1_ps:Bool NTAPS input coefficient sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef lmsfir1_inv0(NTAPS, coefficient, i, input, sum)\ni >= 0 and i <= NTAPS and sum == reduce_sum(vec_elemwise_mul(list_take(coefficient, i), list_take(input, i)))\n\n\n\ndef lmsfir1_ps(NTAPS, input, coefficient, lmsfir1_rv)\nlmsfir1_rv == reduce_sum(vec_elemwise_mul(list_take(coefficient, NTAPS), list_take(input, NTAPS)))\n\n\n\nlmsfir1 synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int (list_take:List Int coefficient NTAPS) (list_take:List Int input NTAPS)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef lmsfir1_np (NTAPS, input, coefficient):\n    return np.sum((coefficient[:NTAPS]) * (input[:NTAPS]))\n\n####### glued code ########\n\ndef lmsfir1_np_glued (NTAPS, input, coefficient):\n    input = np.array(input).astype(np.int32)\n    coefficient = np.array(coefficient).astype(np.int32)\n    return lmsfir1_np(NTAPS, input, coefficient)\n\nSynthesis took 2.0376951694488525 seconds\n",
        "stderr": ""
    },
    "utdsp-lmsfir2": {
        "elapsed_time": 2.2474875160005467,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %NTAPS.addr = alloca i32, align 4\n  %error.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %curr = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %NTAPS, i32* %NTAPS.addr, align 4\n  store i32 %error, i32* %error.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %NTAPS.addr, align 4\n  %sub = sub nsw i32 %i3, 1\n  %cmp = icmp slt i32 %i2, %sub\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %coefficient, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %i8 = load i32, i32* %error.addr, align 4\n  %mul = mul nsw i32 %i7, %i8\n  %add = add nsw i32 %i5, %mul\n  store i32 %add, i32* %curr, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %curr)\n  br label %invoke.cont\n  br label %for.inc\n  %i9 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i9, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (Sub:Int NTAPS (Lit:Int 1)))) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS agg.result coefficient curr error i input)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (Sub:Int NTAPS (Lit:Int 1))))) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS agg.result coefficient curr error i input))) (lmsfir2_ps:Bool NTAPS input coefficient error agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool NTAPS (Lit:Int 1)) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS (list_empty:List Int ) coefficient (Lit:Int 0) error (Lit:Int 0) input)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (Sub:Int NTAPS (Lit:Int 1))) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS agg.result coefficient curr error i input)) (lmsfir2_inv0:Bool NTAPS (list_append:List List Int agg.result (Add:Int (list_get:Int coefficient i) (Mul:Int (list_get:Int input i) error))) coefficient (Add:Int (list_get:Int coefficient i) (Mul:Int (list_get:Int input i) error)) error (Add:Int i (Lit:Int 1)) input)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (Sub:Int NTAPS (Lit:Int 1)))) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS agg.result coefficient curr error i input)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (Sub:Int NTAPS (Lit:Int 1))))) (Ge:Bool NTAPS (Lit:Int 1))) (Ge:Bool (list_length:Int input) NTAPS)) (Ge:Bool (list_length:Int coefficient) NTAPS)) (lmsfir2_inv0:Bool NTAPS agg.result coefficient curr error i input))) (lmsfir2_ps:Bool NTAPS input coefficient error agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef lmsfir2_inv0(NTAPS, agg.result, coefficient, curr, error, i, input)\ni >= 0 and i <= (NTAPS - 1) and agg.result == vec_elemwise_add(list_take(coefficient, i), vec_scalar_mul(error, list_take(input, i)))\n\n\n\ndef lmsfir2_ps(NTAPS, input, coefficient, error, lmsfir2_rv)\nlmsfir2_rv == vec_elemwise_add(list_take(coefficient, (NTAPS - 1)), vec_scalar_mul(error, list_take(input, (NTAPS - 1))))\n\n\n\nlmsfir2 synthesized: (vec_elemwise_add:List Int (list_take:List Int coefficient (Sub:Int NTAPS (Lit:Int 1))) (vec_scalar_mul:List Int error (list_take:List Int input (Sub:Int NTAPS (Lit:Int 1)))))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef lmsfir2_np (NTAPS, input, coefficient, error):\n    return (coefficient[:(NTAPS) - (1)]) + ((error) * (input[:(NTAPS) - (1)]))\n\n####### glued code ########\n\ndef lmsfir2_np_glued (NTAPS, input, coefficient, error):\n    input = np.array(input).astype(np.int32)\n    coefficient = np.array(coefficient).astype(np.int32)\n    return lmsfir2_np(NTAPS, input, coefficient, error)\n\nSynthesis took 2.065821409225464 seconds\n",
        "stderr": ""
    },
    "utdsp-histogram": {
        "elapsed_time": 4.374507958000322,
        "return_code": 1,
        "stdout": "Reading file tenspiler/c2taco/cpp/for_synthesis/utdsp/histogram_.cc:  tenspiler/c2taco/cpp/for_synthesis/utdsp/histogram_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> histogram(int N) {\n    vector<int> vec;\n    for (int i = 0; i < N; ++i) {\n        vec.push_back(0);\n    }\n    return vec;\n}\nReading file tenspiler/c2taco/cpp/for_synthesis/utdsp/histogram_.cc:  tenspiler/c2taco/cpp/for_synthesis/utdsp/histogram_.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> histogram(int N) {\n    vector<int> vec;\n    for (int i = 0; i < N; ++i) {\n        vec.push_back(0);\n    }\n    return vec;\n}\nPush statement: vec.push_back(0)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %N.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %N, i32* %N.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %N.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %bb, label %bb5\n  br label %for.body\n  br label %for.end\n  store i32 0, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i4 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i4, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %bb6, label %bb7\n  br label %nrvo.skipdtor\n  br label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp))) (histogram_ps:Bool N agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (Ge:Bool N (Lit:Int 1)) (histogram_inv0:Bool N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp)) (histogram_inv0:Bool N (list_append:List List Int agg.result (Lit:Int 0)) (Add:Int i (Lit:Int 1)) (Lit:Int 0))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp))) (histogram_ps:Bool N agg.result))]\nStrict grammar with list bound 2 failed\nTrying relaxed grammar...\nasserts: [(Implies:Bool (Ge:Bool N (Lit:Int 1)) (histogram_inv0:Bool N (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (Lt:Bool i N) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp)) (histogram_inv0:Bool N (list_append:List List Int agg.result (Lit:Int 0)) (Add:Int i (Lit:Int 1)) (Lit:Int 0))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp)) (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i N))) (Ge:Bool N (Lit:Int 1))) (histogram_inv0:Bool N agg.result i ref.tmp))) (histogram_ps:Bool N agg.result))]\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 51, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/c2taco/auto/driver/utdsp/histogram_driver.py\", line 16, in <module>\n    run_synthesis_algorithm(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 139, in run_synthesis_algorithm\n    raise e\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 126, in run_synthesis_algorithm\n    run_synthesis_with_bound(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 67, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n"
    },
    "blend-color_burn_8": {
        "elapsed_time": 30.59168382200005,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont21\nname: for.inc22<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont21', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc22']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end24\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %cmp11 = icmp eq i32 %i7, 0\n  br i1 %cmp11, label %if.then, label %if.else\n  store i32 32, i32* %pixel, align 4\n  br label %if.end\n  %i8 = load i32, i32* %row, align 4\n  %conv12 = sext i32 %i8 to i64\n  %call13 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv12) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv14 = sext i32 %i9 to i64\n  %call15 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call13, i64 %conv14) #11\n  %i10 = load i32, i32* %call15, align 4\n  %sub = sub nsw i32 32, %i10\n  %i11 = load i32, i32* %row, align 4\n  %conv16 = sext i32 %i11 to i64\n  %call17 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv16) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv18 = sext i32 %i12 to i64\n  %call19 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call17, i64 %conv18) #11\n  %i13 = load i32, i32* %call19, align 4\n  %div = sdiv i32 %sub, %i13\n  %sub20 = sub nsw i32 32, %div\n  store i32 %sub20, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i14 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i14, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont21\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc22\n  %i15 = load i32, i32* %row, align 4\n  %inc23 = add nsw i32 %i15, 1\n  store i32 %inc23, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec))) (color_burn_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 0)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base col pixel row_vec agg.result row))) (color_burn_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (Sub:Int (Lit:Int 32) (Div:Int (Sub:Int (Lit:Int 32) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int active row) col))) (Lit:Int 32)) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (Sub:Int (Lit:Int 32) (Div:Int (Sub:Int (Lit:Int 32) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int active row) col))) (Lit:Int 32))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (color_burn_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_burn_8_inv0:Bool active agg.result base col pixel row row_vec))) (color_burn_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef color_burn_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef color_burn_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == selection_two_args(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col), select_two_args) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef color_burn_8_ps(base, active, color_burn_8_rv)\ncolor_burn_8_rv == matrix_selection_two_args(base, active, select_two_args)\n\n\n\ndef select_two_args(int_x, int_y)\n32 if int_y == 0 else (32 - ((32 - int_x) / int_y))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ncolor_burn_8 synthesized: (matrix_selection_two_args:List Int base active select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef color_burn_8_np (base, active):\n    return np.where(np.equal(active, 0), 32, (32) - (((32) - (base)) // (active)))\n\n####### glued code ########\n\ndef color_burn_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return color_burn_8_np(base, active)\n\nSynthesis took 30.342205047607422 seconds\n",
        "stderr": ""
    },
    "blend-color_dodge_8": {
        "elapsed_time": 20.558139144999586,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont20\nname: for.inc21<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont20', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc21']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end23\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %cmp11 = icmp eq i32 %i7, 32\n  br i1 %cmp11, label %if.then, label %if.else\n  store i32 32, i32* %pixel, align 4\n  br label %if.end\n  %i8 = load i32, i32* %row, align 4\n  %conv12 = sext i32 %i8 to i64\n  %call13 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv12) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv14 = sext i32 %i9 to i64\n  %call15 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call13, i64 %conv14) #11\n  %i10 = load i32, i32* %call15, align 4\n  %i11 = load i32, i32* %row, align 4\n  %conv16 = sext i32 %i11 to i64\n  %call17 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv16) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv18 = sext i32 %i12 to i64\n  %call19 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call17, i64 %conv18) #11\n  %i13 = load i32, i32* %call19, align 4\n  %sub = sub nsw i32 32, %i13\n  %div = sdiv i32 %i10, %sub\n  store i32 %div, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i14 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i14, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont20\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc21\n  %i15 = load i32, i32* %row, align 4\n  %inc22 = add nsw i32 %i15, 1\n  store i32 %inc22, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec))) (color_dodge_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 32)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 32))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base col pixel row_vec agg.result row))) (color_dodge_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 32))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (Div:Int (list_get:Int (matrix_get:List Int base row) col) (Sub:Int (Lit:Int 32) (list_get:Int (matrix_get:List Int active row) col))) (Lit:Int 32)) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Eq:Bool (list_get:Int (matrix_get:List Int active row) col) (Lit:Int 32))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (Div:Int (list_get:Int (matrix_get:List Int base row) col) (Sub:Int (Lit:Int 32) (list_get:Int (matrix_get:List Int active row) col))) (Lit:Int 32))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (color_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (color_dodge_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (color_dodge_8_inv0:Bool active agg.result base col pixel row row_vec))) (color_dodge_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef color_dodge_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef color_dodge_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == selection_two_args(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col), select_two_args) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef color_dodge_8_ps(base, active, color_dodge_8_rv)\ncolor_dodge_8_rv == matrix_selection_two_args(base, active, select_two_args)\n\n\n\ndef select_two_args(int_x, int_y)\n32 if int_y == 32 else (int_x / (32 - int_y))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ncolor_dodge_8 synthesized: (matrix_selection_two_args:List Int base active select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef color_dodge_8_np (base, active):\n    return np.where(np.equal(active, 32), 32, (base) // ((32) - (active)))\n\n####### glued code ########\n\ndef color_dodge_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return color_dodge_8_np(base, active)\n\nSynthesis took 20.344167232513428 seconds\n\n\ngenerated code:matrix_selection_two_args(base, active, select_two_args)\n",
        "stderr": ""
    },
    "blend-darken_blend_8": {
        "elapsed_time": 14.623149106999335,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont24\nname: for.inc25<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont24', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc25']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end27\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %cmp15 = icmp sgt i32 %i7, %i10\n  br i1 %cmp15, label %if.then, label %if.else\n  %i11 = load i32, i32* %row, align 4\n  %conv16 = sext i32 %i11 to i64\n  %call17 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv16) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv18 = sext i32 %i12 to i64\n  %call19 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call17, i64 %conv18) #11\n  %i13 = load i32, i32* %call19, align 4\n  store i32 %i13, i32* %pixel, align 4\n  br label %if.end\n  %i14 = load i32, i32* %row, align 4\n  %conv20 = sext i32 %i14 to i64\n  %call21 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv20) #11\n  %i15 = load i32, i32* %col, align 4\n  %conv22 = sext i32 %i15 to i64\n  %call23 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call21, i64 %conv22) #11\n  %i16 = load i32, i32* %call23, align 4\n  store i32 %i16, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i17 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i17, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont24\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc25\n  %i18 = load i32, i32* %row, align 4\n  %inc26 = add nsw i32 %i18, 1\n  store i32 %inc26, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (darken_blend_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Gt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base col pixel row_vec agg.result row))) (darken_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Gt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Gt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (darken_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (darken_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (darken_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (darken_blend_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef darken_blend_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef darken_blend_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == selection_two_args(list_take(matrix_get(active, row), col), list_take(matrix_get(base, row), col), select_two_args) and agg.result == matrix_selection_two_args(matrix_take(active, row), matrix_take(base, row), select_two_args)\n\n\n\ndef darken_blend_8_ps(base, active, darken_blend_8_rv)\ndarken_blend_8_rv == matrix_selection_two_args(base, active, select_two_args)\n\n\n\ndef select_two_args(int_x, int_y)\nint_x if int_y > int_x else int_y\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndarken_blend_8 synthesized: (matrix_selection_two_args:List Int base active select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef darken_blend_8_np (base, active):\n    return np.where(np.greater(active, base), base, active)\n\n####### glued code ########\n\ndef darken_blend_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return darken_blend_8_np(base, active)\n\nSynthesis took 14.335012912750244 seconds\n",
        "stderr": ""
    },
    "blend-dissolve_blend_8": {
        "elapsed_time": 34.37765965500148,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont16\nname: for.inc17<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont16', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc17']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %opacity.addr = alloca i32, align 4\n  %rand_cons.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %rand_val = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i32 %opacity, i32* %opacity.addr, align 4\n  store i32 %rand_cons, i32* %rand_cons.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end19\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %rand_cons.addr, align 4\n  %rem = srem i32 %i5, 100\n  %add = add nsw i32 %rem, 1\n  %div = sdiv i32 %add, 100\n  store i32 %div, i32* %rand_val, align 4\n  %i6 = load i32, i32* %opacity.addr, align 4\n  %i7 = load i32, i32* %rand_val, align 4\n  %sub = sub nsw i32 %i6, %i7\n  %cmp7 = icmp sge i32 %sub, 0\n  br i1 %cmp7, label %if.then, label %if.else\n  %i8 = load i32, i32* %row, align 4\n  %conv8 = sext i32 %i8 to i64\n  %call9 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv8) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv10 = sext i32 %i9 to i64\n  %call11 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call9, i64 %conv10) #11\n  %i10 = load i32, i32* %call11, align 4\n  store i32 %i10, i32* %pixel, align 4\n  br label %if.end\n  %i11 = load i32, i32* %row, align 4\n  %conv12 = sext i32 %i11 to i64\n  %call13 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv12) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv14 = sext i32 %i12 to i64\n  %call15 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call13, i64 %conv14) #11\n  %i13 = load i32, i32* %call15, align 4\n  store i32 %i13, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i14 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i14, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont16\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc17\n  %i15 = load i32, i32* %row, align 4\n  %inc18 = add nsw i32 %i15, 1\n  store i32 %inc18, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec))) (dissolve_blend_8_ps:Bool base active opacity rand_cons agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) opacity (Lit:Int 0) rand_cons (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base (Lit:Int 0) opacity pixel rand_cons rand_val (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool (Sub:Int opacity (Div:Int (Add:Int (Mod:Int rand_cons (Lit:Int 100)) (Lit:Int 1)) (Lit:Int 100))) (Lit:Int 0)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base col opacity pixel rand_cons rand_val row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (Sub:Int opacity (Div:Int (Add:Int (Mod:Int rand_cons (Lit:Int 100)) (Lit:Int 1)) (Lit:Int 100))) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base col opacity pixel rand_cons rand_val row_vec agg.result row))) (dissolve_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) opacity (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (Sub:Int opacity (Div:Int (Add:Int (Mod:Int rand_cons (Lit:Int 100)) (Lit:Int 1)) (Lit:Int 100))) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base col opacity pixel rand_cons rand_val row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) rand_cons (Div:Int (Add:Int (Mod:Int rand_cons (Lit:Int 100)) (Lit:Int 1)) (Lit:Int 100)) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (Sub:Int opacity (Div:Int (Add:Int (Mod:Int rand_cons (Lit:Int 100)) (Lit:Int 1)) (Lit:Int 100))) (Lit:Int 0))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base col opacity pixel rand_cons rand_val row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (dissolve_blend_8_inv1:Bool active base col opacity pixel rand_cons rand_val row_vec agg.result row)) (dissolve_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col opacity pixel rand_cons rand_val (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (dissolve_blend_8_inv0:Bool active agg.result base col opacity pixel rand_cons rand_val row row_vec))) (dissolve_blend_8_ps:Bool base active opacity rand_cons agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef dissolve_blend_8_inv0(active, agg.result, base, col, opacity, pixel, rand_cons, rand_val, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == dissolve_matrix_selection_two_args(matrix_take(active, row), matrix_take(base, row), opacity, rand_cons, dissolve_select_two_args)\n\n\n\ndef dissolve_blend_8_inv1(active, base, col, opacity, pixel, rand_cons, rand_val, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == dissolve_selection_two_args(list_take(matrix_get(active, row), col), list_take(matrix_get(base, row), col), opacity, rand_cons, dissolve_select_two_args) and agg.result == dissolve_matrix_selection_two_args(matrix_take(active, row), matrix_take(base, row), opacity, rand_cons, dissolve_select_two_args)\n\n\n\ndef dissolve_blend_8_ps(base, active, opacity, rand_cons, dissolve_blend_8_rv)\ndissolve_blend_8_rv == dissolve_matrix_selection_two_args(active, base, opacity, rand_cons, dissolve_select_two_args)\n\n\n\ndef dissolve_select_two_args(int_x, int_y, opacity, rand_cons)\nint_x if (opacity - (((Mod:Int rand_cons (Lit:Int 100)) + 1) / 100)) >= 0 else int_y\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndissolve_blend_8 synthesized: (dissolve_matrix_selection_two_args:List Int active base opacity rand_cons dissolve_select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef dissolve_blend_8_np (base, active, opacity, rand_cons):\n    return np.where((opacity) - ((((rand_cons) % (100)) + (1)) / (100)) >= 0, active, base)\n\n####### glued code ########\n\ndef dissolve_blend_8_np_glued (base, active, opacity, rand_cons):\n    base = np.array(base).astype(np.float32)\n    active = np.array(active).astype(np.float32)\n    return dissolve_blend_8_np(base, active, opacity, rand_cons)\n\nSynthesis took 34.1402370929718 seconds\n",
        "stderr": ""
    },
    "blend-lighten_blend_8": {
        "elapsed_time": 16.60062287099936,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont24\nname: for.inc25<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont24', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc25']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end27\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %cmp15 = icmp slt i32 %i7, %i10\n  br i1 %cmp15, label %if.then, label %if.else\n  %i11 = load i32, i32* %row, align 4\n  %conv16 = sext i32 %i11 to i64\n  %call17 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv16) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv18 = sext i32 %i12 to i64\n  %call19 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call17, i64 %conv18) #11\n  %i13 = load i32, i32* %call19, align 4\n  store i32 %i13, i32* %pixel, align 4\n  br label %if.end\n  %i14 = load i32, i32* %row, align 4\n  %conv20 = sext i32 %i14 to i64\n  %call21 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv20) #11\n  %i15 = load i32, i32* %col, align 4\n  %conv22 = sext i32 %i15 to i64\n  %call23 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call21, i64 %conv22) #11\n  %i16 = load i32, i32* %call23, align 4\n  store i32 %i16, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i17 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i17, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont24\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc25\n  %i18 = load i32, i32* %row, align 4\n  %inc26 = add nsw i32 %i18, 1\n  store i32 %inc26, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (lighten_blend_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base col pixel row_vec agg.result row))) (lighten_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (lighten_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (lighten_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (lighten_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (lighten_blend_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef lighten_blend_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef lighten_blend_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == selection_two_args(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col), select_two_args) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(active, row), select_two_args)\n\n\n\ndef lighten_blend_8_ps(base, active, lighten_blend_8_rv)\nlighten_blend_8_rv == matrix_selection_two_args(base, active, select_two_args)\n\n\n\ndef select_two_args(int_x, int_y)\nint_x if int_y < int_x else int_y\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nlighten_blend_8 synthesized: (matrix_selection_two_args:List Int base active select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef lighten_blend_8_np (base, active):\n    return np.where(np.less(active, base), base, active)\n\n####### glued code ########\n\ndef lighten_blend_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return lighten_blend_8_np(base, active)\n\nSynthesis took 16.351110696792603 seconds\n",
        "stderr": ""
    },
    "blend-linear_burn_8": {
        "elapsed_time": 12.458805342999767,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont15\nname: for.inc16<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont15', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc16']\nfound loop: header: for.cond4, body: ['for.body6', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end18\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %add = add nsw i32 %i7, %i10\n  %sub = sub nsw i32 %add, 32\n  store i32 %sub, i32* %pixel, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i11 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i11, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont15\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc16\n  %i12 = load i32, i32* %row, align 4\n  %inc17 = add nsw i32 %i12, 1\n  store i32 %inc17, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec))) (linear_burn_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_burn_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0)))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (linear_burn_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Sub:Int (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32)) (list_append:List List Int row_vec (Sub:Int (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_burn_8_inv1:Bool active base col pixel row_vec agg.result row)) (linear_burn_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_burn_8_inv0:Bool active agg.result base col pixel row row_vec))) (linear_burn_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef linear_burn_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_scalar_sub(32, matrix_elemwise_add(matrix_take(base, row), matrix_take(active, row)))\n\n\n\ndef linear_burn_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == vec_scalar_sub(32, vec_elemwise_add(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col))) and agg.result == matrix_scalar_sub(32, matrix_elemwise_add(matrix_take(base, row), matrix_take(active, row)))\n\n\n\ndef linear_burn_8_ps(base, active, linear_burn_8_rv)\nlinear_burn_8_rv == matrix_scalar_sub(32, matrix_elemwise_add(active, base))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nlinear_burn_8 synthesized: (matrix_scalar_sub:List Int (Lit:Int 32) (matrix_elemwise_add:List Int active base))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef linear_burn_8_np (base, active):\n    return ((active) + (base)) - (32)\n\n####### glued code ########\n\ndef linear_burn_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return linear_burn_8_np(base, active)\n\nSynthesis took 12.256240367889404 seconds\n",
        "stderr": ""
    },
    "blend-linear_dodge_8": {
        "elapsed_time": 6.4565019920009945,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont15\nname: for.inc16<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont15', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc16']\nfound loop: header: for.cond4, body: ['for.body6', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end18\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %add = add nsw i32 %i7, %i10\n  store i32 %add, i32* %pixel, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i11 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i11, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont15\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc16\n  %i12 = load i32, i32* %row, align 4\n  %inc17 = add nsw i32 %i12, 1\n  store i32 %inc17, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec))) (linear_dodge_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_dodge_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0)))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (linear_dodge_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (list_append:List List Int row_vec (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (linear_dodge_8_inv1:Bool active base col pixel row_vec agg.result row)) (linear_dodge_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (linear_dodge_8_inv0:Bool active agg.result base col pixel row row_vec))) (linear_dodge_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef linear_dodge_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_elemwise_add(matrix_take(base, row), matrix_take(active, row))\n\n\n\ndef linear_dodge_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == vec_elemwise_add(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col)) and agg.result == matrix_elemwise_add(matrix_take(base, row), matrix_take(active, row))\n\n\n\ndef linear_dodge_8_ps(base, active, linear_dodge_8_rv)\nlinear_dodge_8_rv == matrix_elemwise_add(base, active)\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nlinear_dodge_8 synthesized: (matrix_elemwise_add:List Int base active)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef linear_dodge_8_np (base, active):\n    return (base) + (active)\n\n####### glued code ########\n\ndef linear_dodge_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return linear_dodge_8_np(base, active)\n\nSynthesis took 6.2466139793396 seconds\n",
        "stderr": ""
    },
    "blend-multiply_blend_8": {
        "elapsed_time": 6.494072712999696,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont15\nname: for.inc16<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont15', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc16']\nfound loop: header: for.cond4, body: ['for.body6', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end18\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %mul = mul nsw i32 %i7, %i10\n  %div = sdiv i32 %mul, 32\n  store i32 %div, i32* %pixel, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i11 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i11, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont15\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc16\n  %i12 = load i32, i32* %row, align 4\n  %inc17 = add nsw i32 %i12, 1\n  store i32 %inc17, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (multiply_blend_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (multiply_blend_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0)))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (multiply_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (multiply_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Div:Int (Mul:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32)) (list_append:List List Int row_vec (Div:Int (Mul:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (multiply_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (multiply_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (multiply_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (multiply_blend_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef multiply_blend_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_scalar_div(32, matrix_elemwise_mul(matrix_take(active, row), matrix_take(base, row)))\n\n\n\ndef multiply_blend_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == vec_scalar_div(32, vec_elemwise_mul(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col))) and agg.result == matrix_scalar_div(32, matrix_elemwise_mul(matrix_take(active, row), matrix_take(base, row)))\n\n\n\ndef multiply_blend_8_ps(base, active, multiply_blend_8_rv)\nmultiply_blend_8_rv == matrix_scalar_div(32, matrix_elemwise_mul(base, active))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nmultiply_blend_8 synthesized: (matrix_scalar_div:List Int (Lit:Int 32) (matrix_elemwise_mul:List Int base active))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef multiply_blend_8_np (base, active):\n    return ((base) * (active)) // (32)\n\n####### glued code ########\n\ndef multiply_blend_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return multiply_blend_8_np(base, active)\n\nSynthesis took 6.281310558319092 seconds\n",
        "stderr": ""
    },
    "blend-normal_blend_8": {
        "elapsed_time": 4.2504767419995915,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %opacity.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %opacity, i32* %opacity.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %conv = sext i32 %i2 to i64\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %opacity.addr, align 4\n  %i4 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i4 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv1) #11\n  %i5 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i3, %i5\n  %i6 = load i32, i32* %opacity.addr, align 4\n  %sub = sub nsw i32 32, %i6\n  %i7 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i7 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv3) #11\n  %i8 = load i32, i32* %call4, align 4\n  %mul5 = mul nsw i32 %sub, %i8\n  %add = add nsw i32 %mul, %mul5\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i9 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i9, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int base))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active agg.result base i opacity ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int base)))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active agg.result base i opacity ref.tmp))) (normal_blend_8_ps:Bool base active opacity agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Eq:Bool (list_length:Int base) (list_length:Int active)) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active (list_empty:List Int ) base (Lit:Int 0) opacity (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (list_length:Int base)) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active agg.result base i opacity ref.tmp)) (normal_blend_8_inv0:Bool active (list_append:List List Int agg.result (Add:Int (Mul:Int opacity (list_get:Int active i)) (Mul:Int (Sub:Int (Lit:Int 32) opacity) (list_get:Int base i)))) base (Add:Int i (Lit:Int 1)) opacity (Add:Int (Mul:Int opacity (list_get:Int active i)) (Mul:Int (Sub:Int (Lit:Int 32) opacity) (list_get:Int base i))))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int base))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active agg.result base i opacity ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int base)))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_8_inv0:Bool active agg.result base i opacity ref.tmp))) (normal_blend_8_ps:Bool base active opacity agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef normal_blend_8_inv0(active, agg.result, base, i, opacity, ref.tmp)\ni >= 0 and i <= list_length(base) and agg.result == vec_elemwise_add(vec_scalar_mul(opacity, list_take(active, i)), vec_scalar_mul((32 - opacity), list_take(base, i)))\n\n\n\ndef normal_blend_8_ps(base, active, opacity, normal_blend_8_rv)\nnormal_blend_8_rv == vec_elemwise_add(vec_scalar_mul(opacity, active), vec_scalar_mul((32 - opacity), base))\n\n\n\nnormal_blend_8 synthesized: (vec_elemwise_add:List Int (vec_scalar_mul:List Int opacity active) (vec_scalar_mul:List Int (Sub:Int (Lit:Int 32) opacity) base))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef normal_blend_8_np (base, active, opacity):\n    return ((opacity) * (active)) + (((32) - (opacity)) * (base))\n\n####### glued code ########\n\ndef normal_blend_8_np_glued (base, active, opacity):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return normal_blend_8_np(base, active, opacity)\n\nSynthesis took 4.071157932281494 seconds\n",
        "stderr": ""
    },
    "blend-normal_blend_f": {
        "elapsed_time": 2.275847356999293,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %opacity.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %opacity, i32* %opacity.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %conv = sext i32 %i2 to i64\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %opacity.addr, align 4\n  %i4 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i4 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv1) #11\n  %i5 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i3, %i5\n  %i6 = load i32, i32* %opacity.addr, align 4\n  %sub = sub nsw i32 1, %i6\n  %i7 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i7 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv3) #11\n  %i8 = load i32, i32* %call4, align 4\n  %mul5 = mul nsw i32 %sub, %i8\n  %add = add nsw i32 %mul, %mul5\n  store i32 %add, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i9 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i9, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int base))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active agg.result base i opacity ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int base)))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active agg.result base i opacity ref.tmp))) (normal_blend_f_ps:Bool base active opacity agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Eq:Bool (list_length:Int base) (list_length:Int active)) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active (list_empty:List Int ) base (Lit:Int 0) opacity (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (list_length:Int base)) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active agg.result base i opacity ref.tmp)) (normal_blend_f_inv0:Bool active (list_append:List List Int agg.result (Add:Int (Mul:Int opacity (list_get:Int active i)) (Mul:Int (Sub:Int (Lit:Int 1) opacity) (list_get:Int base i)))) base (Add:Int i (Lit:Int 1)) opacity (Add:Int (Mul:Int opacity (list_get:Int active i)) (Mul:Int (Sub:Int (Lit:Int 1) opacity) (list_get:Int base i))))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int base))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active agg.result base i opacity ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int base)))) (Eq:Bool (list_length:Int base) (list_length:Int active))) (Gt:Bool (list_length:Int base) (Lit:Int 0))) (normal_blend_f_inv0:Bool active agg.result base i opacity ref.tmp))) (normal_blend_f_ps:Bool base active opacity agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef normal_blend_f_inv0(active, agg.result, base, i, opacity, ref.tmp)\ni >= 0 and i <= list_length(base) and agg.result == vec_elemwise_add(vec_scalar_mul(opacity, list_take(active, i)), vec_scalar_mul((1 - opacity), list_take(base, i)))\n\n\n\ndef normal_blend_f_ps(base, active, opacity, normal_blend_f_rv)\nnormal_blend_f_rv == vec_elemwise_add(vec_scalar_mul(opacity, active), vec_scalar_mul((1 - opacity), base))\n\n\n\nnormal_blend_f synthesized: (vec_elemwise_add:List Int (vec_scalar_mul:List Int opacity active) (vec_scalar_mul:List Int (Sub:Int (Lit:Int 1) opacity) base))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef normal_blend_f_np (base, active, opacity):\n    return ((opacity) * (active)) + (((1) - (opacity)) * (base))\n\n####### glued code ########\n\ndef normal_blend_f_np_glued (base, active, opacity):\n    base = np.array(base).astype(np.float32)\n    active = np.array(active).astype(np.float32)\n    return normal_blend_f_np(base, active, opacity)\n\nSynthesis took 2.089195728302002 seconds\n",
        "stderr": ""
    },
    "blend-overlay_blend_8": {
        "elapsed_time": 38.88295872600065,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont42\nname: for.inc43<latch>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: if.else\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont42', 'for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc43']\nfound loop: header: for.cond4, body: ['for.body6', 'if.else', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end45\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %cmp11 = icmp sge i32 %i7, 16\n  br i1 %cmp11, label %if.then, label %if.else\n  %i8 = load i32, i32* %row, align 4\n  %conv12 = sext i32 %i8 to i64\n  %call13 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv12) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv14 = sext i32 %i9 to i64\n  %call15 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call13, i64 %conv14) #11\n  %i10 = load i32, i32* %call15, align 4\n  %mul = mul nsw i32 2, %i10\n  %i11 = load i32, i32* %row, align 4\n  %conv16 = sext i32 %i11 to i64\n  %call17 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv16) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv18 = sext i32 %i12 to i64\n  %call19 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call17, i64 %conv18) #11\n  %i13 = load i32, i32* %call19, align 4\n  %add = add nsw i32 %mul, %i13\n  %i14 = load i32, i32* %row, align 4\n  %conv20 = sext i32 %i14 to i64\n  %call21 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv20) #11\n  %i15 = load i32, i32* %col, align 4\n  %conv22 = sext i32 %i15 to i64\n  %call23 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call21, i64 %conv22) #11\n  %i16 = load i32, i32* %call23, align 4\n  %mul24 = mul nsw i32 2, %i16\n  %i17 = load i32, i32* %row, align 4\n  %conv25 = sext i32 %i17 to i64\n  %call26 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv25) #11\n  %i18 = load i32, i32* %col, align 4\n  %conv27 = sext i32 %i18 to i64\n  %call28 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call26, i64 %conv27) #11\n  %i19 = load i32, i32* %call28, align 4\n  %mul29 = mul nsw i32 %mul24, %i19\n  %div = sdiv i32 %mul29, 32\n  %sub = sub nsw i32 %add, %div\n  %sub30 = sub nsw i32 %sub, 32\n  store i32 %sub30, i32* %pixel, align 4\n  br label %if.end\n  %i20 = load i32, i32* %row, align 4\n  %conv31 = sext i32 %i20 to i64\n  %call32 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv31) #11\n  %i21 = load i32, i32* %col, align 4\n  %conv33 = sext i32 %i21 to i64\n  %call34 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call32, i64 %conv33) #11\n  %i22 = load i32, i32* %call34, align 4\n  %mul35 = mul nsw i32 2, %i22\n  %i23 = load i32, i32* %row, align 4\n  %conv36 = sext i32 %i23 to i64\n  %call37 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv36) #11\n  %i24 = load i32, i32* %col, align 4\n  %conv38 = sext i32 %i24 to i64\n  %call39 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call37, i64 %conv38) #11\n  %i25 = load i32, i32* %call39, align 4\n  %mul40 = mul nsw i32 %mul35, %i25\n  %div41 = sdiv i32 %mul40, 32\n  store i32 %div41, i32* %pixel, align 4\n  br label %if.end\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i26 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i26, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont42\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc43\n  %i27 = load i32, i32* %row, align 4\n  %inc44 = add nsw i32 %i27, 1\n  store i32 %inc44, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (overlay_blend_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool (list_get:Int (matrix_get:List Int base row) col) (Lit:Int 16)) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (list_get:Int (matrix_get:List Int base row) col) (Lit:Int 16))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base col pixel row_vec agg.result row))) (overlay_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (list_get:Int (matrix_get:List Int base row) col) (Lit:Int 16))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (Div:Int (Mul:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Lit:Int 32)) (Sub:Int (Sub:Int (Add:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Div:Int (Mul:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Lit:Int 32))) (Lit:Int 32))) (list_append:List List Int row_vec (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Ge:Bool (list_get:Int (matrix_get:List Int base row) col) (Lit:Int 16))) (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (Div:Int (Mul:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Lit:Int 32)) (Sub:Int (Sub:Int (Add:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Div:Int (Mul:Int (Mul:Int (Lit:Int 2) (list_get:Int (matrix_get:List Int base row) col)) (list_get:Int (matrix_get:List Int base row) col)) (Lit:Int 32))) (Lit:Int 32)))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (overlay_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (overlay_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (overlay_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (overlay_blend_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef overlay_blend_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(base, row), select_two_args)\n\n\n\ndef overlay_blend_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == selection_two_args(list_take(matrix_get(base, row), col), list_take(matrix_get(base, row), col), select_two_args) and agg.result == matrix_selection_two_args(matrix_take(base, row), matrix_take(base, row), select_two_args)\n\n\n\ndef overlay_blend_8_ps(base, active, overlay_blend_8_rv)\noverlay_blend_8_rv == matrix_selection_two_args(base, base, select_two_args)\n\n\n\ndef select_two_args(int_x, int_y)\n((((2 * int_x) + int_x) - (((2 * int_x) * int_x) / 32)) - 32) if int_x >= 16 else (((2 * int_x) * int_x) / 32)\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\noverlay_blend_8 synthesized: (matrix_selection_two_args:List Int base base select_two_args)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef overlay_blend_8_np (base, active):\n    return np.where(np.greater_equal(base, 16), ((((2) * (base)) + (base)) - ((((2) * (base)) * (base)) // (32))) - (32), (((2) * (base)) * (base)) // (32))\n\n####### glued code ########\n\ndef overlay_blend_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return overlay_blend_8_np(base, active)\n\nSynthesis took 38.510053634643555 seconds\n",
        "stderr": ""
    },
    "blend-screen_blend_8": {
        "elapsed_time": 26.61604190399885,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond4\nname: for.end\nname: invoke.cont23\nname: for.inc24<latch>\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond4', 'for.end', 'invoke.cont23', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc24']\nfound loop: header: for.cond4, body: ['for.body6', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %col = alloca i32, align 4\n  %pixel = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %base) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 0) #11\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #11\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end26\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  store i32 0, i32* %col, align 4\n  br label %for.cond4\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i3, %i4\n  br i1 %cmp5, label %for.body6, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv7 = sext i32 %i5 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv7) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv9 = sext i32 %i6 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #11\n  %i7 = load i32, i32* %call10, align 4\n  %i8 = load i32, i32* %row, align 4\n  %conv11 = sext i32 %i8 to i64\n  %call12 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv11) #11\n  %i9 = load i32, i32* %col, align 4\n  %conv13 = sext i32 %i9 to i64\n  %call14 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call12, i64 %conv13) #11\n  %i10 = load i32, i32* %call14, align 4\n  %add = add nsw i32 %i7, %i10\n  %i11 = load i32, i32* %row, align 4\n  %conv15 = sext i32 %i11 to i64\n  %call16 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %base, i64 %conv15) #11\n  %i12 = load i32, i32* %col, align 4\n  %conv17 = sext i32 %i12 to i64\n  %call18 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call16, i64 %conv17) #11\n  %i13 = load i32, i32* %call18, align 4\n  %i14 = load i32, i32* %row, align 4\n  %conv19 = sext i32 %i14 to i64\n  %call20 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %active, i64 %conv19) #11\n  %i15 = load i32, i32* %col, align 4\n  %conv21 = sext i32 %i15 to i64\n  %call22 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call20, i64 %conv21) #11\n  %i16 = load i32, i32* %call22, align 4\n  %mul = mul nsw i32 %i13, %i16\n  %div = sdiv i32 %mul, 32\n  %sub = sub nsw i32 %add, %div\n  store i32 %sub, i32* %pixel, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %pixel)\n  br label %invoke.cont\n  br label %for.inc\n  %i17 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i17, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont23\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector.0\"* %row_vec) #11\n  br label %for.inc24\n  %i18 = load i32, i32* %row, align 4\n  %inc25 = add nsw i32 %i18, 1\n  store i32 %inc25, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (screen_blend_8_ps:Bool base active agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int base) (Lit:Int 1)) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active (matrix_empty:List Int ) base (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int base)) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (screen_blend_8_inv1:Bool active base (Lit:Int 0) pixel (list_empty:List Int ) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0)))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (screen_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (screen_blend_8_inv1:Bool active base (Add:Int col (Lit:Int 1)) (Sub:Int (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Div:Int (Mul:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32))) (list_append:List List Int row_vec (Sub:Int (Add:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Div:Int (Mul:Int (list_get:Int (matrix_get:List Int base row) col) (list_get:Int (matrix_get:List Int active row) col)) (Lit:Int 32)))) agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int (matrix_get:List Int base (Lit:Int 0))))) (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (screen_blend_8_inv1:Bool active base col pixel row_vec agg.result row)) (screen_blend_8_inv0:Bool active (matrix_append:List List Int agg.result row_vec) base col pixel (Add:Int row (Lit:Int 1)) row_vec)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int base))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int base)))) (Gt:Bool (matrix_length:Int base) (Lit:Int 1))) (Eq:Bool (matrix_length:Int base) (matrix_length:Int active))) (Eq:Bool (list_length:Int (matrix_get:List Int base (Lit:Int 0))) (list_length:Int (matrix_get:List Int active (Lit:Int 0))))) (screen_blend_8_inv0:Bool active agg.result base col pixel row row_vec))) (screen_blend_8_ps:Bool base active agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef screen_blend_8_inv0(active, agg.result, base, col, pixel, row, row_vec)\nrow >= 0 and row <= matrix_length(base) and agg.result == matrix_elemwise_sub(matrix_elemwise_add(matrix_take(active, row), matrix_take(base, row)), matrix_scalar_div(32, matrix_elemwise_mul(matrix_take(active, row), matrix_take(base, row))))\n\n\n\ndef screen_blend_8_inv1(active, base, col, pixel, row_vec, agg.result, row)\nrow >= 0 and row <= matrix_length(base) and col >= 0 and col <= list_length(matrix_get(base, 0)) and row_vec == vec_elemwise_sub(vec_elemwise_add(list_take(matrix_get(active, row), col), list_take(matrix_get(base, row), col)), vec_scalar_div(32, vec_elemwise_mul(list_take(matrix_get(base, row), col), list_take(matrix_get(active, row), col)))) and agg.result == matrix_elemwise_sub(matrix_elemwise_add(matrix_take(active, row), matrix_take(base, row)), matrix_scalar_div(32, matrix_elemwise_mul(matrix_take(active, row), matrix_take(base, row))))\n\n\n\ndef screen_blend_8_ps(base, active, screen_blend_8_rv)\nscreen_blend_8_rv == matrix_elemwise_sub(matrix_elemwise_add(active, base), matrix_scalar_div(32, matrix_elemwise_mul(base, active)))\n\n\n\ndef OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nscreen_blend_8 synthesized: (matrix_elemwise_sub:List Int (matrix_elemwise_add:List Int active base) (matrix_scalar_div:List Int (Lit:Int 32) (matrix_elemwise_mul:List Int base active)))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef screen_blend_8_np (base, active):\n    return ((active) + (base)) - (((base) * (active)) // (32))\n\n####### glued code ########\n\ndef screen_blend_8_np_glued (base, active):\n    base = np.array(base).astype(np.uint8)\n    active = np.array(active).astype(np.uint8)\n    return screen_blend_8_np(base, active)\n\nSynthesis took 26.38274312019348 seconds\n",
        "stderr": ""
    },
    "llama-rmsnorm_part1": {
        "elapsed_time": 2.218930820001333,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %ss = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 0, i32* %ss, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %conv = sext i32 %i1 to i64\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %input) #1\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %for.body, label %for.end\n  %i2 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i2 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv1) #1\n  %i3 = load i32, i32* %call2, align 4\n  %i4 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i4 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv3) #1\n  %i5 = load i32, i32* %call4, align 4\n  %mul = mul nsw i32 %i3, %i5\n  %i6 = load i32, i32* %ss, align 4\n  %add = add nsw i32 %i6, %mul\n  store i32 %add, i32* %ss, align 4\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i8 = load i32, i32* %ss, align 4\n  ret i32 %i8\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int input))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part1_inv0:Bool i input ss weight)) (rmsnorm_part1_ps:Bool input weight ss))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Eq:Bool (list_length:Int input) (list_length:Int weight)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part1_inv0:Bool (Lit:Int 0) input (Lit:Int 0) weight)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (list_length:Int input)) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part1_inv0:Bool i input ss weight)) (rmsnorm_part1_inv0:Bool (Add:Int i (Lit:Int 1)) input (Add:Int ss (Mul:Int (list_get:Int input i) (list_get:Int input i))) weight)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int input))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part1_inv0:Bool i input ss weight)) (rmsnorm_part1_ps:Bool input weight ss))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef rmsnorm_part1_inv0(i, input, ss, weight)\ni >= 0 and i <= list_length(input) and ss == reduce_sum(vec_elemwise_mul(list_take(input, i), list_take(input, i)))\n\n\n\ndef rmsnorm_part1_ps(input, weight, rmsnorm_part1_rv)\nrmsnorm_part1_rv == reduce_sum(vec_elemwise_mul(input, input))\n\n\n\nrmsnorm_part1 synthesized: (reduce_sum:Int (vec_elemwise_mul:List Int input input))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef rmsnorm_part1_np (input, weight):\n    return np.sum((input) * (input))\n\n####### glued code ########\n\ndef rmsnorm_part1_np_glued (input, weight):\n    input = np.array(input).astype(np.float32)\n    weight = np.array(weight).astype(np.float32)\n    return rmsnorm_part1_np(input, weight)\n\nSynthesis took 2.0454108715057373 seconds\n",
        "stderr": ""
    },
    "llama-rmsnorm_part2": {
        "elapsed_time": 2.3317743509996944,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont10\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont10'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %ss.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %size = alloca i32, align 4\n  %inv_ss = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %ss, i32* %ss.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %input) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %size, align 4\n  %i2 = load i32, i32* %ss.addr, align 4\n  %i3 = load i32, i32* %size, align 4\n  %div = sdiv i32 %i2, %i3\n  %add = add nsw i32 %div, 1\n  %call1 = call i32 @_Z12integer_sqrti(i32 %add)\n  br label %invoke.cont\n  %div2 = sdiv i32 1, %call1\n  store i32 %div2, i32* %inv_ss, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i4 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i4 to i64\n  %call4 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %input) #11\n  %cmp = icmp ult i64 %conv3, %call4\n  br i1 %cmp, label %for.body, label %for.end\n  %i5 = load i32, i32* %inv_ss, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv5 = sext i32 %i6 to i64\n  %call6 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv5) #11\n  %i7 = load i32, i32* %call6, align 4\n  %mul = mul nsw i32 %i5, %i7\n  %i8 = load i32, i32* %i, align 4\n  %conv7 = sext i32 %i8 to i64\n  %call8 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %weight, i64 %conv7) #11\n  %i9 = load i32, i32* %call8, align 4\n  %mul9 = mul nsw i32 %mul, %i9\n  store i32 %mul9, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont10\n  br label %for.inc\n  %i10 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i10, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int input))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool agg.result i input ref.tmp ss weight)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int input)))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool agg.result i input ref.tmp ss weight))) (rmsnorm_part2_ps:Bool input weight ss agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Eq:Bool (list_length:Int input) (list_length:Int weight)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool (list_empty:List Int ) (Lit:Int 0) input (Lit:Int 0) ss weight)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (list_length:Int input)) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool agg.result i input ref.tmp ss weight)) (rmsnorm_part2_inv0:Bool (list_append:List List Int agg.result (Mul:Int (Mul:Int (Div:Int (Lit:Int 1) (integer_sqrt:Int (Add:Int (Div:Int ss (list_length:Int input)) (Lit:Int 1)))) (list_get:Int input i)) (list_get:Int weight i))) (Add:Int i (Lit:Int 1)) input (Mul:Int (Mul:Int (Div:Int (Lit:Int 1) (integer_sqrt:Int (Add:Int (Div:Int ss (list_length:Int input)) (Lit:Int 1)))) (list_get:Int input i)) (list_get:Int weight i)) ss weight)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i (list_length:Int input))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool agg.result i input ref.tmp ss weight)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (list_length:Int input)))) (Eq:Bool (list_length:Int input) (list_length:Int weight))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (rmsnorm_part2_inv0:Bool agg.result i input ref.tmp ss weight))) (rmsnorm_part2_ps:Bool input weight ss agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef rmsnorm_part2_inv0(agg.result, i, input, ref.tmp, ss, weight)\ni >= 0 and i <= list_length(input) and agg.result == vec_scalar_mul((1 / integer_sqrt(((ss / list_length(input)) + 1))), vec_elemwise_mul(list_take(weight, i), list_take(input, i)))\n\n\n\ndef rmsnorm_part2_ps(input, weight, ss, rmsnorm_part2_rv)\nrmsnorm_part2_rv == vec_scalar_mul((1 / integer_sqrt(((ss / list_length(input)) + 1))), vec_elemwise_mul(weight, input))\n\n\n\nrmsnorm_part2 synthesized: (vec_scalar_mul:List Int (Div:Int (Lit:Int 1) (integer_sqrt:Int (Add:Int (Div:Int ss (list_length:Int input)) (Lit:Int 1)))) (vec_elemwise_mul:List Int weight input))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef rmsnorm_part2_np (input, weight, ss):\n    return ((1) / (np.sqrt(((ss) / (input.size)) + (1)))) * ((weight) * (input))\n\n####### glued code ########\n\ndef rmsnorm_part2_np_glued (input, weight, ss):\n    input = np.array(input).astype(np.float32)\n    weight = np.array(weight).astype(np.float32)\n    return rmsnorm_part2_np(input, weight, ss)\n\nSynthesis took 2.147149085998535 seconds\n",
        "stderr": ""
    },
    "llama-softmax_part1": {
        "elapsed_time": 6.402662518999932,
        "return_code": 1,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: if.then\nname: if.end\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'if.then', 'if.end'], exits: ['for.cond'], latches: ['for.inc']\n  %max_pos.addr = alloca i32, align 4\n  %max_val = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %max_pos, i32* %max_pos.addr, align 4\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 0) #1\n  %i1 = load i32, i32* %call, align 4\n  store i32 %i1, i32* %max_val, align 4\n  store i32 1, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %max_pos.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call1 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv) #1\n  %i5 = load i32, i32* %call1, align 4\n  %i6 = load i32, i32* %max_val, align 4\n  %cmp2 = icmp sgt i32 %i5, %i6\n  br i1 %cmp2, label %if.then, label %if.end\n  %i7 = load i32, i32* %i, align 4\n  %conv3 = sext i32 %i7 to i64\n  %call4 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv3) #1\n  %i8 = load i32, i32* %call4, align 4\n  store i32 %i8, i32* %max_val, align 4\n  br label %if.end\n  br label %for.inc\n  %i9 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i9, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i10 = load i32, i32* %max_val, align 4\n  ret i32 %i10\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (softmax_part1_ps:Bool input max_pos max_val))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (list_length:Int input) (Lit:Int 0)) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool (Lit:Int 1) input max_pos (list_get:Int input (Lit:Int 0)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i max_pos) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool (list_get:Int input i) max_val) (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val))) (softmax_part1_inv0:Bool (Add:Int i (Lit:Int 1)) input max_pos (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool (list_get:Int input i) max_val) (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (list_get:Int input i) max_val))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (softmax_part1_ps:Bool input max_pos max_val))]\nStrict grammar with list bound 2 failed\nTrying relaxed grammar...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (list_length:Int input) (Lit:Int 0)) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool (Lit:Int 1) input max_pos (list_get:Int input (Lit:Int 0)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i max_pos) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool (list_get:Int input i) max_val) (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val))) (softmax_part1_inv0:Bool (Add:Int i (Lit:Int 1)) input max_pos (Ite:Int (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool (list_get:Int input i) max_val) (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (list_get:Int input i) max_val))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part1_inv0:Bool i input max_pos max_val)) (softmax_part1_ps:Bool input max_pos max_val))]\n====== verification of round 0 solution ======\nSynthesized PS and INV Candidates\n\ndef softmax_part1_inv0(i input max_pos max_val)\ni >= 1 and i <= max_pos and max_val == reduce_max(vec_slice(input, 0, i))\n\n\n\ndef softmax_part1_ps(input max_pos softmax_part1_rv)\nsoftmax_part1_rv == reduce_max(vec_slice(input, 0, max_pos))\n\n\n\nVerification Output: SAT/UNKNOWN\nverification failed (FnDeclRecursive:Function  softmax_part1_inv0 (And:Bool (And:Bool (Ge:Bool i (Lit:Int 1)) (Le:Bool i max_pos)) (Eq:Bool max_val (reduce_max:Int (vec_slice:List Int input (Lit:Int 0) i)))) i input max_pos max_val)\n\n(FnDeclRecursive:Function  softmax_part1_ps (Eq:Bool softmax_part1_rv (reduce_max:Int (vec_slice:List Int input (Lit:Int 0) max_pos))) input max_pos softmax_part1_rv)\n\n\nProceeding to verifying the next solution\n",
        "stderr": "Traceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 51, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/llama/holing/driver/softmax/softmax_part1_driver.py\", line 74, in <module>\n    run_synthesis_algorithm(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 139, in run_synthesis_algorithm\n    raise e\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 126, in run_synthesis_algorithm\n    run_synthesis_with_bound(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/utils/synthesis_utils.py\", line 67, in run_synthesis_with_bound\n    driver.synthesize(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1619, in synthesize\n    synthesized: List[FnDeclRecursive] = run_synthesis(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/synthesize_rosette.py\", line 679, in synthesize\n    raise SynthesisFailed(\"Synthesis failed\")\nmetalift.synthesis_common.SynthesisFailed: Synthesis failed\n"
    },
    "llama-softmax_part2": {
        "elapsed_time": 2.2417199580013403,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: invoke.cont2\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont', 'invoke.cont2'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %max_pos.addr = alloca i32, align 4\n  %max_val.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %cur = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %max_pos, i32* %max_pos.addr, align 4\n  store i32 %max_val, i32* %max_val.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %max_pos.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %max_val.addr, align 4\n  %sub = sub nsw i32 %i5, %i6\n  %call1 = call i32 @_Z11integer_expi(i32 %sub)\n  br label %invoke.cont\n  store i32 %call1, i32* %cur, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %cur)\n  br label %invoke.cont2\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool agg.result cur i input max_pos max_val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i max_pos))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool agg.result cur i input max_pos max_val))) (softmax_part2_ps:Bool input max_pos max_val agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (list_length:Int input) (Lit:Int 0)) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0) input max_pos max_val)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i max_pos) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool agg.result cur i input max_pos max_val)) (softmax_part2_inv0:Bool (list_append:List List Int agg.result (integer_exp:Int (Sub:Int (list_get:Int input i) max_val))) (integer_exp:Int (Sub:Int (list_get:Int input i) max_val)) (Add:Int i (Lit:Int 1)) input max_pos max_val)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool agg.result cur i input max_pos max_val)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i max_pos))) (Gt:Bool (list_length:Int input) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int input))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part2_inv0:Bool agg.result cur i input max_pos max_val))) (softmax_part2_ps:Bool input max_pos max_val agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef softmax_part2_inv0(agg.result, cur, i, input, max_pos, max_val)\ni >= 0 and i <= max_pos and agg.result == vec_map(vec_scalar_sub(max_val, list_take(input, i)), map_int_to_int)\n\n\n\ndef softmax_part2_ps(input, max_pos, max_val, softmax_part2_rv)\nsoftmax_part2_rv == vec_map(vec_scalar_sub(max_val, list_take(input, max_pos)), map_int_to_int)\n\n\n\ndef map_int_to_int(int_x)\ninteger_exp(int_x)\n\n\n\nsoftmax_part2 synthesized: (vec_map:List Int (vec_scalar_sub:List Int max_val (list_take:List Int input max_pos)) map_int_to_int)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef softmax_part2_np (input, max_pos, max_val):\n    return np.exp((input[:max_pos]) - (max_val))\n\n####### glued code ########\n\ndef softmax_part2_np_glued (input, max_pos, max_val):\n    input = np.array(input).astype(np.float32)\n    return softmax_part2_np(input, max_pos, max_val)\n\nSynthesis took 2.064818859100342 seconds\n",
        "stderr": ""
    },
    "llama-softmax_part3": {
        "elapsed_time": 2.1900783279997995,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body'], exits: ['for.cond'], latches: ['for.inc']\n  %max_pos.addr = alloca i32, align 4\n  %sum = alloca i32, align 4\n  %i = alloca i32, align 4\n  store i32 %max_pos, i32* %max_pos.addr, align 4\n  store i32 0, i32* %sum, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %i, align 4\n  %i2 = load i32, i32* %max_pos.addr, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end\n  %i3 = load i32, i32* %i, align 4\n  %conv = sext i32 %i3 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %output, i64 %conv) #1\n  %i4 = load i32, i32* %call, align 4\n  %i5 = load i32, i32* %sum, align 4\n  %add = add nsw i32 %i5, %i4\n  store i32 %add, i32* %sum, align 4\n  br label %for.inc\n  %i6 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  %i7 = load i32, i32* %sum, align 4\n  ret i32 %i7\nps: (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part3_inv0:Bool i max_pos output sum)) (softmax_part3_ps:Bool output max_pos sum))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (list_length:Int output) (Lit:Int 0)) (Le:Bool max_pos (list_length:Int output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part3_inv0:Bool (Lit:Int 0) max_pos output (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i max_pos) (Gt:Bool (list_length:Int output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part3_inv0:Bool i max_pos output sum)) (softmax_part3_inv0:Bool (Add:Int i (Lit:Int 1)) max_pos output (Add:Int sum (list_get:Int output i)))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part3_inv0:Bool i max_pos output sum)) (softmax_part3_ps:Bool output max_pos sum))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef softmax_part3_inv0(i, max_pos, output, sum)\ni >= 0 and i <= max_pos and sum == reduce_sum(list_take(output, i))\n\n\n\ndef softmax_part3_ps(output, max_pos, softmax_part3_rv)\nsoftmax_part3_rv == reduce_sum(list_take(output, max_pos))\n\n\n\nsoftmax_part3 synthesized: (reduce_sum:Int (list_take:List Int output max_pos))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef softmax_part3_np (output, max_pos):\n    return np.sum(output[:max_pos])\n\n####### glued code ########\n\ndef softmax_part3_np_glued (output, max_pos):\n    output = np.array(output).astype(np.float32)\n    return softmax_part3_np(output, max_pos)\n\nSynthesis took 2.02020263671875 seconds\n",
        "stderr": ""
    },
    "llama-softmax_part4": {
        "elapsed_time": 2.2186823950014514,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %max_pos.addr = alloca i32, align 4\n  %sum.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %max_pos, i32* %max_pos.addr, align 4\n  store i32 %sum, i32* %sum.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %max_pos.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %unnormalized_output, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %sum.addr, align 4\n  %div = sdiv i32 %i5, %i6\n  store i32 %div, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i7 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i7, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool agg.result i max_pos ref.tmp sum unnormalized_output)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i max_pos))) (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool agg.result i max_pos ref.tmp sum unnormalized_output))) (softmax_part4_ps:Bool unnormalized_output max_pos sum agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0)) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool (list_empty:List Int ) (Lit:Int 0) max_pos (Lit:Int 0) sum unnormalized_output)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i max_pos) (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool agg.result i max_pos ref.tmp sum unnormalized_output)) (softmax_part4_inv0:Bool (list_append:List List Int agg.result (Div:Int (list_get:Int unnormalized_output i) sum)) (Add:Int i (Lit:Int 1)) max_pos (Div:Int (list_get:Int unnormalized_output i) sum) sum unnormalized_output)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i max_pos)) (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool agg.result i max_pos ref.tmp sum unnormalized_output)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i max_pos))) (Gt:Bool (list_length:Int unnormalized_output) (Lit:Int 0))) (Le:Bool max_pos (list_length:Int unnormalized_output))) (Ge:Bool max_pos (Lit:Int 1))) (softmax_part4_inv0:Bool agg.result i max_pos ref.tmp sum unnormalized_output))) (softmax_part4_ps:Bool unnormalized_output max_pos sum agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef softmax_part4_inv0(agg.result, i, max_pos, ref.tmp, sum, unnormalized_output)\ni >= 0 and i <= max_pos and agg.result == vec_scalar_div(sum, list_take(unnormalized_output, i))\n\n\n\ndef softmax_part4_ps(unnormalized_output, max_pos, sum, softmax_part4_rv)\nlist_eq(softmax_part4_rv, vec_scalar_div(sum, list_take(unnormalized_output, max_pos)))\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef softmax_part4_np (unnormalized_output, max_pos, sum):\n    return (unnormalized_output[:max_pos]) / (sum)\n\n####### glued code ########\n\ndef softmax_part4_np_glued (unnormalized_output, max_pos, sum):\n    unnormalized_output = np.array(unnormalized_output).astype(np.float32)\n    return softmax_part4_np(unnormalized_output, max_pos, sum)\n\nSynthesis took 2.045074462890625 seconds\n",
        "stderr": ""
    },
    "llama-transformer_part1": {
        "elapsed_time": 14.423422839001432,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont\nname: invoke.cont14\nname: for.inc15<latch>\nname: for.body3\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont', 'invoke.cont14', 'for.body3', 'for.inc'], exits: ['for.cond'], latches: ['for.inc15']\nfound loop: header: for.cond1, body: ['for.body3'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %token_position.addr = alloca i32, align 4\n  %head1.addr = alloca i32, align 4\n  %head_size.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %timestep = alloca i32, align 4\n  %score = alloca i32, align 4\n  %i = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %token_position, i32* %token_position.addr, align 4\n  store i32 %head1, i32* %head1.addr, align 4\n  store i32 %head_size, i32* %head_size.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %timestep, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %timestep, align 4\n  %i3 = load i32, i32* %token_position.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end17\n  store i32 0, i32* %score, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %i, align 4\n  %i5 = load i32, i32* %head_size.addr, align 4\n  %cmp2 = icmp slt i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %head1.addr, align 4\n  %i7 = load i32, i32* %head_size.addr, align 4\n  %mul = mul nsw i32 %i6, %i7\n  %i8 = load i32, i32* %i, align 4\n  %add = add nsw i32 %mul, %i8\n  %conv = sext i32 %add to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %q, i64 %conv) #11\n  %i9 = load i32, i32* %call, align 4\n  %i10 = load i32, i32* %timestep, align 4\n  %conv4 = sext i32 %i10 to i64\n  %call5 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %key_cache_layer, i64 %conv4) #11\n  %i11 = load i32, i32* %head1.addr, align 4\n  %i12 = load i32, i32* %head_size.addr, align 4\n  %mul6 = mul nsw i32 %i11, %i12\n  %i13 = load i32, i32* %i, align 4\n  %add7 = add nsw i32 %mul6, %i13\n  %conv8 = sext i32 %add7 to i64\n  %call9 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %call5, i64 %conv8) #11\n  %i14 = load i32, i32* %call9, align 4\n  %mul10 = mul nsw i32 %i9, %i14\n  %i15 = load i32, i32* %score, align 4\n  %add11 = add nsw i32 %i15, %mul10\n  store i32 %add11, i32* %score, align 4\n  br label %for.inc\n  %i16 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i16, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond1\n  %i17 = load i32, i32* %head_size.addr, align 4\n  %mul12 = mul nsw i32 %i17, 1\n  %call13 = call i32 @_Z12integer_sqrti(i32 %mul12)\n  br label %invoke.cont\n  %i18 = load i32, i32* %score, align 4\n  %div = sdiv i32 %i18, %call13\n  store i32 %div, i32* %score, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %score)\n  br label %invoke.cont14\n  br label %for.inc15\n  %i19 = load i32, i32* %timestep, align 4\n  %inc16 = add nsw i32 %i19, 1\n  store i32 %inc16, i32* %timestep, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool timestep token_position)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool timestep token_position))) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position))) (transformer_part1_ps:Bool token_position head1 head_size key_cache_layer q agg.result))\nStarting synthesis at list bound 3\nTrying strict grammar with list bound 3...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool token_position (Lit:Int 0)) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool (list_empty:List Int ) head1 head_size (Lit:Int 0) key_cache_layer q (Lit:Int 0) (Lit:Int 0) token_position)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool timestep token_position) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position)) (transformer_part1_inv1:Bool head1 head_size (Lit:Int 0) key_cache_layer q (Lit:Int 0) token_position agg.result timestep)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i head_size) (Lt:Bool timestep token_position)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position)) (transformer_part1_inv1:Bool head1 head_size i key_cache_layer q score token_position agg.result timestep)) (transformer_part1_inv1:Bool head1 head_size (Add:Int i (Lit:Int 1)) key_cache_layer q (Add:Int score (Mul:Int (list_get:Int q (Add:Int (Mul:Int head1 head_size) i)) (list_get:Int (matrix_get:List Int key_cache_layer timestep) (Add:Int (Mul:Int head1 head_size) i)))) token_position agg.result timestep)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i head_size)) (Lt:Bool timestep token_position)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position)) (transformer_part1_inv1:Bool head1 head_size i key_cache_layer q score token_position agg.result timestep)) (transformer_part1_inv0:Bool (list_append:List List Int agg.result (Div:Int score (integer_sqrt:Int (Mul:Int head_size (Lit:Int 1))))) head1 head_size i key_cache_layer q (Div:Int score (integer_sqrt:Int (Mul:Int head_size (Lit:Int 1)))) (Add:Int timestep (Lit:Int 1)) token_position)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool timestep token_position)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool timestep token_position))) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int q))) (Le:Bool head1 (matrix_length:Int key_cache_layer))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int q))) (Le:Bool head_size (matrix_length:Int key_cache_layer))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))))) (Lt:Bool (Add:Int (Mul:Int head1 head_size) head_size) (list_length:Int q))) (transformer_part1_inv0:Bool agg.result head1 head_size i key_cache_layer q score timestep token_position))) (transformer_part1_ps:Bool token_position head1 head_size key_cache_layer q agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef transformer_part1_inv0(agg.result, head1, head_size, i, key_cache_layer, q, score, timestep, token_position)\ntimestep >= 0 and timestep <= token_position and agg.result == vec_scalar_div(integer_sqrt(SQRT_ARG_FN(token_position, head1, head_size)), matrix_vec_mul(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, timestep), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size)), vec_slice(q, VEC_COMPOSED_INDEX_FN(token_position, head1, head_size), (VEC_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size))))\n\n\n\ndef transformer_part1_inv1(head1, head_size, i, key_cache_layer, q, score, token_position, agg.result, timestep)\ntimestep >= 0 and timestep < token_position and i >= 0 and i <= head_size and score == reduce_sum(vec_elemwise_mul(vec_slice(matrix_get(key_cache_layer, timestep), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + i)), vec_slice(q, VEC_COMPOSED_INDEX_FN(token_position, head1, head_size), (VEC_COMPOSED_INDEX_FN(token_position, head1, head_size) + i)))) and agg.result == vec_scalar_div(integer_sqrt(SQRT_ARG_FN(token_position, head1, head_size)), matrix_vec_mul(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, timestep), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size)), vec_slice(q, VEC_COMPOSED_INDEX_FN(token_position, head1, head_size), (VEC_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size))))\n\n\n\ndef transformer_part1_ps(token_position, head1, head_size, key_cache_layer, q, transformer_part1_rv)\ntransformer_part1_rv == vec_scalar_div(integer_sqrt(SQRT_ARG_FN(token_position, head1, head_size)), matrix_vec_mul(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, token_position), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size)), vec_slice(q, VEC_COMPOSED_INDEX_FN(token_position, head1, head_size), (VEC_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size))))\n\n\n\ndef VEC_COMPOSED_INDEX_FN(token_position, head1, head_size)\n(head1 * head_size)\n\n\n\ndef SQRT_ARG_FN(token_position, head1, head_size)\n(1 * head_size)\n\n\n\ndef MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size)\n(head1 * head_size)\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndef VECTOR_OUTER_LOOP_INDEX()\nFalse\n\n\n\ntransformer_part1 synthesized: (vec_scalar_div:List Int (integer_sqrt:Int (SQRT_ARG_FN:Int token_position head1 head_size)) (matrix_vec_mul:List Int (matrix_col_slice:List Int (matrix_row_slice:List Int key_cache_layer (Lit:Int 0) token_position) (MATRIX_COMPOSED_INDEX_FN:Int token_position head1 head_size) (Add:Int (MATRIX_COMPOSED_INDEX_FN:Int token_position head1 head_size) head_size)) (vec_slice:List Int q (VEC_COMPOSED_INDEX_FN:Int token_position head1 head_size) (Add:Int (VEC_COMPOSED_INDEX_FN:Int token_position head1 head_size) head_size))))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef transformer_part1_np (token_position, head1, head_size, key_cache_layer, q):\n    return (np.matmul(key_cache_layer[0:token_position][:, (head1) * (head_size):((head1) * (head_size)) + (head_size)], q[(head1) * (head_size):((head1) * (head_size)) + (head_size)])) // (np.sqrt((1) * (head_size)))\n\n####### glued code ########\n\ndef transformer_part1_np_glued (token_position, head1, head_size, key_cache_layer, q):\n    key_cache_layer = np.array(key_cache_layer).astype(np.int32)\n    q = np.array(q).astype(np.int32)\n    return transformer_part1_np(token_position, head1, head_size, key_cache_layer, q)\n\nSynthesis took 14.222274780273438 seconds\n",
        "stderr": ""
    },
    "llama-transformer_part2": {
        "elapsed_time": 6.313137484001345,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond1\nname: for.end\nname: invoke.cont\nname: for.inc10<latch>\nname: for.body3\nname: for.inc\nname: for.cond1<header><exiting>\nname: for.body3\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond1', 'for.end', 'invoke.cont', 'for.body3', 'for.inc'], exits: ['for.cond'], latches: ['for.inc10']\nfound loop: header: for.cond1, body: ['for.body3'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %token_position.addr = alloca i32, align 4\n  %head1.addr = alloca i32, align 4\n  %head_size.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %curr = alloca i32, align 4\n  %timestep = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %token_position, i32* %token_position.addr, align 4\n  store i32 %head1, i32* %head1.addr, align 4\n  store i32 %head_size, i32* %head_size.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %head_size.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end12\n  store i32 0, i32* %curr, align 4\n  store i32 0, i32* %timestep, align 4\n  br label %for.cond1\n  %i4 = load i32, i32* %timestep, align 4\n  %i5 = load i32, i32* %token_position.addr, align 4\n  %cmp2 = icmp sle i32 %i4, %i5\n  br i1 %cmp2, label %for.body3, label %for.end\n  %i6 = load i32, i32* %timestep, align 4\n  %conv = sext i32 %i6 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %attention, i64 %conv) #11\n  %i7 = load i32, i32* %call, align 4\n  %i8 = load i32, i32* %timestep, align 4\n  %conv4 = sext i32 %i8 to i64\n  %call5 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %key_cache_layer, i64 %conv4) #11\n  %i9 = load i32, i32* %head1.addr, align 4\n  %i10 = load i32, i32* %head_size.addr, align 4\n  %mul = mul nsw i32 %i9, %i10\n  %i11 = load i32, i32* %i, align 4\n  %add = add nsw i32 %mul, %i11\n  %conv6 = sext i32 %add to i64\n  %call7 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %call5, i64 %conv6) #11\n  %i12 = load i32, i32* %call7, align 4\n  %mul8 = mul nsw i32 %i7, %i12\n  %i13 = load i32, i32* %curr, align 4\n  %add9 = add nsw i32 %i13, %mul8\n  store i32 %add9, i32* %curr, align 4\n  br label %for.inc\n  %i14 = load i32, i32* %timestep, align 4\n  %inc = add nsw i32 %i14, 1\n  store i32 %inc, i32* %timestep, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %curr)\n  br label %invoke.cont\n  br label %for.inc10\n  %i15 = load i32, i32* %i, align 4\n  %inc11 = add nsw i32 %i15, 1\n  store i32 %inc11, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i head_size)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i head_size))) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position))) (transformer_part2_ps:Bool token_position head1 head_size key_cache_layer attention agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Gt:Bool token_position (Lit:Int 0)) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool (list_empty:List Int ) attention (Lit:Int 0) head1 head_size (Lit:Int 0) key_cache_layer (Lit:Int 0) token_position)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i head_size) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position)) (transformer_part2_inv1:Bool attention (Lit:Int 0) head1 head_size key_cache_layer (Lit:Int 0) token_position agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Le:Bool timestep token_position) (Lt:Bool i head_size)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position)) (transformer_part2_inv1:Bool attention curr head1 head_size key_cache_layer timestep token_position agg.result i)) (transformer_part2_inv1:Bool attention (Add:Int curr (Mul:Int (list_get:Int attention timestep) (list_get:Int (matrix_get:List Int key_cache_layer timestep) (Add:Int (Mul:Int head1 head_size) i)))) head1 head_size key_cache_layer (Add:Int timestep (Lit:Int 1)) token_position agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Le:Bool timestep token_position)) (Lt:Bool i head_size)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position)) (transformer_part2_inv1:Bool attention curr head1 head_size key_cache_layer timestep token_position agg.result i)) (transformer_part2_inv0:Bool (list_append:List List Int agg.result curr) attention curr head1 head_size (Add:Int i (Lit:Int 1)) key_cache_layer timestep token_position)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i head_size)) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i head_size))) (Gt:Bool token_position (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Lit:Int 0))) (Gt:Bool (list_length:Int attention) (Lit:Int 0))) (Gt:Bool (matrix_length:Int key_cache_layer) token_position)) (Gt:Bool (list_length:Int (matrix_get:List Int key_cache_layer (Lit:Int 0))) (Add:Int (Mul:Int head1 head_size) head_size))) (Gt:Bool (list_length:Int attention) token_position)) (Ge:Bool head1 (Lit:Int 0))) (Le:Bool head1 (list_length:Int attention))) (Gt:Bool head_size (Lit:Int 0))) (Le:Bool head_size (list_length:Int attention))) (transformer_part2_inv0:Bool agg.result attention curr head1 head_size i key_cache_layer timestep token_position))) (transformer_part2_ps:Bool token_position head1 head_size key_cache_layer attention agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef transformer_part2_inv0(agg.result, attention, curr, head1, head_size, i, key_cache_layer, timestep, token_position)\ni >= 0 and i <= head_size and agg.result == matrix_vec_mul(matrix_transpose(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, (token_position + 1)), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + i))), vec_slice(attention, 0, (token_position + 1)))\n\n\n\ndef transformer_part2_inv1(attention, curr, head1, head_size, key_cache_layer, timestep, token_position, agg.result, i)\ni >= 0 and i < head_size and timestep >= 0 and timestep <= (token_position + 1) and curr == reduce_sum(vec_elemwise_mul(matrix_get(matrix_transpose(matrix_col_slice_with_length(matrix_row_slice(key_cache_layer, 0, timestep), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + i), 1)), 0), vec_slice(attention, 0, timestep))) and agg.result == matrix_vec_mul(matrix_transpose(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, (token_position + 1)), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + i))), vec_slice(attention, 0, (token_position + 1)))\n\n\n\ndef transformer_part2_ps(token_position, head1, head_size, key_cache_layer, attention, transformer_part2_rv)\nlist_eq(transformer_part2_rv, matrix_vec_mul(matrix_transpose(matrix_col_slice(matrix_row_slice(key_cache_layer, 0, (token_position + 1)), MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size), (MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size) + head_size))), vec_slice(attention, 0, (token_position + 1))))\n\n\n\ndef MATRIX_COMPOSED_INDEX_FN(token_position, head1, head_size)\n(head1 * head_size)\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nFalse\n\n\n\ndef VECTOR_OUTER_LOOP_INDEX()\nFalse\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef transformer_part2_np (token_position, head1, head_size, key_cache_layer, attention):\n    return np.matmul(np.transpose(key_cache_layer[0:(token_position) + (1)][:, (head1) * (head_size):((head1) * (head_size)) + (head_size)]), attention[0:(token_position) + (1)])\n\n####### glued code ########\n\ndef transformer_part2_np_glued (token_position, head1, head_size, key_cache_layer, attention):\n    key_cache_layer = np.array(key_cache_layer).astype(np.int32)\n    attention = np.array(attention).astype(np.int32)\n    return transformer_part2_np(token_position, head1, head_size, key_cache_layer, attention)\n\nSynthesis took 6.127072811126709 seconds\n",
        "stderr": ""
    },
    "llama-transformer_part3": {
        "elapsed_time": 2.2998489339988737,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: invoke.cont4\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont', 'invoke.cont4'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %hidden_dim.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %curr = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %hidden_dim, i32* %hidden_dim.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %hidden_dim.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %sub = sub nsw i32 0, %i7\n  %call3 = call i32 @_Z11integer_expi(i32 %sub)\n  br label %invoke.cont\n  %add = add nsw i32 1, %call3\n  %div = sdiv i32 1, %add\n  %mul = mul nsw i32 %i5, %div\n  store i32 %mul, i32* %curr, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %curr)\n  br label %invoke.cont4\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i hidden_dim)) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool agg.result curr hidden_dim i input)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i hidden_dim))) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool agg.result curr hidden_dim i input))) (transformer_part3_ps:Bool input hidden_dim agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Ge:Bool hidden_dim (Lit:Int 0)) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool (list_empty:List Int ) (Lit:Int 0) hidden_dim (Lit:Int 0) input)), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i hidden_dim) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool agg.result curr hidden_dim i input)) (transformer_part3_inv0:Bool (list_append:List List Int agg.result (Mul:Int (list_get:Int input i) (Div:Int (Lit:Int 1) (Add:Int (Lit:Int 1) (integer_exp:Int (Sub:Int (Lit:Int 0) (list_get:Int input i))))))) (Mul:Int (list_get:Int input i) (Div:Int (Lit:Int 1) (Add:Int (Lit:Int 1) (integer_exp:Int (Sub:Int (Lit:Int 0) (list_get:Int input i)))))) hidden_dim (Add:Int i (Lit:Int 1)) input)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i hidden_dim)) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool agg.result curr hidden_dim i input)) (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i hidden_dim))) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input) hidden_dim)) (transformer_part3_inv0:Bool agg.result curr hidden_dim i input))) (transformer_part3_ps:Bool input hidden_dim agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef transformer_part3_inv0(agg.result, curr, hidden_dim, i, input)\ni >= 0 and i <= hidden_dim and agg.result == vec_elemwise_mul(list_take(input, i), scalar_vec_div(1, vec_scalar_add(1, vec_map(scalar_vec_sub(0, list_take(input, i)), map_int_to_int))))\n\n\n\ndef transformer_part3_ps(input, hidden_dim, transformer_part3_rv)\nlist_eq(transformer_part3_rv, vec_elemwise_mul(list_take(input, hidden_dim), scalar_vec_div(1, vec_scalar_add(1, vec_map(scalar_vec_sub(0, list_take(input, hidden_dim)), map_int_to_int)))))\n\n\n\ndef map_int_to_int(int_x)\ninteger_exp(int_x)\n\n\n\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef transformer_part3_np (input, hidden_dim):\n    return (input[:hidden_dim]) * ((1) / ((1) + (np.exp((0) - (input[:hidden_dim])))))\n\n####### glued code ########\n\ndef transformer_part3_np_glued (input, hidden_dim):\n    input = np.array(input).astype(np.float32)\n    return transformer_part3_np(input, hidden_dim)\n\nSynthesis took 2.1029577255249023 seconds\n",
        "stderr": ""
    },
    "llama-transformer_part4": {
        "elapsed_time": 2.243239703000654,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %hidden_dim.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %hidden_dim, i32* %hidden_dim.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %hidden_dim.addr, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %for.body, label %for.end\n  %i4 = load i32, i32* %i, align 4\n  %conv = sext i32 %i4 to i64\n  %call = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input1, i64 %conv) #11\n  %i5 = load i32, i32* %call, align 4\n  %i6 = load i32, i32* %i, align 4\n  %conv1 = sext i32 %i6 to i64\n  %call2 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input2, i64 %conv1) #11\n  %i7 = load i32, i32* %call2, align 4\n  %mul = mul nsw i32 %i5, %i7\n  store i32 %mul, i32* %ref.tmp, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backEOi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %ref.tmp)\n  br label %invoke.cont\n  br label %for.inc\n  %i8 = load i32, i32* %i, align 4\n  %inc = add nsw i32 %i8, 1\n  store i32 %inc, i32* %i, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i hidden_dim)) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool agg.result hidden_dim i input1 input2 ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i hidden_dim))) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool agg.result hidden_dim i input1 input2 ref.tmp))) (transformer_part4_ps:Bool input1 input2 hidden_dim agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Ge:Bool hidden_dim (Lit:Int 0)) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool (list_empty:List Int ) hidden_dim (Lit:Int 0) input1 input2 (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i hidden_dim) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool agg.result hidden_dim i input1 input2 ref.tmp)) (transformer_part4_inv0:Bool (list_append:List List Int agg.result (Mul:Int (list_get:Int input1 i) (list_get:Int input2 i))) hidden_dim (Add:Int i (Lit:Int 1)) input1 input2 (Mul:Int (list_get:Int input1 i) (list_get:Int input2 i)))), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool i hidden_dim)) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool agg.result hidden_dim i input1 input2 ref.tmp)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i hidden_dim))) (Ge:Bool hidden_dim (Lit:Int 0))) (Ge:Bool (list_length:Int input1) hidden_dim)) (Ge:Bool (list_length:Int input2) hidden_dim)) (transformer_part4_inv0:Bool agg.result hidden_dim i input1 input2 ref.tmp))) (transformer_part4_ps:Bool input1 input2 hidden_dim agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef transformer_part4_inv0(agg.result, hidden_dim, i, input1, input2, ref.tmp)\ni >= 0 and i <= hidden_dim and agg.result == vec_elemwise_mul(list_take(input1, i), list_take(input2, i))\n\n\n\ndef transformer_part4_ps(input1, input2, hidden_dim, transformer_part4_rv)\ntransformer_part4_rv == vec_elemwise_mul(list_take(input1, hidden_dim), list_take(input2, hidden_dim))\n\n\n\ntransformer_part4 synthesized: (vec_elemwise_mul:List Int (list_take:List Int input1 hidden_dim) (list_take:List Int input2 hidden_dim))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef transformer_part4_np (input1, input2, hidden_dim):\n    return (input1[:hidden_dim]) * (input2[:hidden_dim])\n\n####### glued code ########\n\ndef transformer_part4_np_glued (input1, input2, hidden_dim):\n    input1 = np.array(input1).astype(np.float32)\n    input2 = np.array(input2).astype(np.float32)\n    return transformer_part4_np(input1, input2, hidden_dim)\n\nSynthesis took 2.061176300048828 seconds\n",
        "stderr": ""
    },
    "llama-matmul": {
        "elapsed_time": 6.375627594999969,
        "return_code": 0,
        "stdout": "name: for.cond<header><exiting>\nname: for.body\nname: for.cond3\nname: for.end\nname: invoke.cont\nname: for.inc12<latch>\nname: for.body5\nname: for.inc\nname: for.cond3<header><exiting>\nname: for.body5\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['for.body', 'for.cond3', 'for.end', 'invoke.cont', 'for.body5', 'for.inc'], exits: ['for.cond'], latches: ['for.inc12']\nfound loop: header: for.cond3, body: ['for.body5'], exits: ['for.cond3'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %row = alloca i32, align 4\n  %curr = alloca i32, align 4\n  %col = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector.1\"* %weight) #11\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %input) #11\n  %conv2 = trunc i64 %call1 to i32\n  store i32 %conv2, i32* %n, align 4\n  store i32 0, i32* %row, align 4\n  br label %for.cond\n  %i1 = load i32, i32* %row, align 4\n  %i2 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i1, %i2\n  br i1 %cmp, label %for.body, label %for.end14\n  store i32 0, i32* %curr, align 4\n  store i32 0, i32* %col, align 4\n  br label %for.cond3\n  %i3 = load i32, i32* %col, align 4\n  %i4 = load i32, i32* %n, align 4\n  %cmp4 = icmp slt i32 %i3, %i4\n  br i1 %cmp4, label %for.body5, label %for.end\n  %i5 = load i32, i32* %row, align 4\n  %conv6 = sext i32 %i5 to i64\n  %call7 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %weight, i64 %conv6) #11\n  %i6 = load i32, i32* %col, align 4\n  %conv8 = sext i32 %i6 to i64\n  %call9 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %call7, i64 %conv8) #11\n  %i7 = load i32, i32* %call9, align 4\n  %i8 = load i32, i32* %col, align 4\n  %conv10 = sext i32 %i8 to i64\n  %call11 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector\"* %input, i64 %conv10) #11\n  %i9 = load i32, i32* %call11, align 4\n  %mul = mul nsw i32 %i7, %i9\n  %i10 = load i32, i32* %curr, align 4\n  %add = add nsw i32 %i10, %mul\n  store i32 %add, i32* %curr, align 4\n  br label %for.inc\n  %i11 = load i32, i32* %col, align 4\n  %inc = add nsw i32 %i11, 1\n  store i32 %inc, i32* %col, align 4\n  br label %for.cond3\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector\"* %agg.result, i32* nonnull align 4 dereferenceable(4) %curr)\n  br label %invoke.cont\n  br label %for.inc12\n  %i12 = load i32, i32* %row, align 4\n  %inc13 = add nsw i32 %i12, 1\n  store i32 %inc13, i32* %row, align 4\n  br label %for.cond\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %nrvo.skipdtor, label %nrvo.unused\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED1Ev(%\"class.std::__1::vector\"* %agg.result) #11\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int weight))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int weight)))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight))) (matmul_ps:Bool weight input agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (Gt:Bool (matrix_length:Int weight) (Lit:Int 0)) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool (list_empty:List Int ) (Lit:Int 0) (Lit:Int 0) input (Lit:Int 0) weight)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool row (matrix_length:Int weight)) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight)) (matmul_inv1:Bool (Lit:Int 0) (Lit:Int 0) input weight agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool col (list_length:Int input)) (Lt:Bool row (matrix_length:Int weight))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight)) (matmul_inv1:Bool col curr input weight agg.result row)) (matmul_inv1:Bool (Add:Int col (Lit:Int 1)) (Add:Int curr (Mul:Int (list_get:Int (matrix_get:List Int weight row) col) (list_get:Int input col))) input weight agg.result row)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool col (list_length:Int input))) (Lt:Bool row (matrix_length:Int weight))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight)) (matmul_inv1:Bool col curr input weight agg.result row)) (matmul_inv0:Bool (list_append:List List Int agg.result curr) col curr input (Add:Int row (Lit:Int 1)) weight)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool row (matrix_length:Int weight))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool row (matrix_length:Int weight)))) (Gt:Bool (matrix_length:Int weight) (Lit:Int 0))) (Gt:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (Lit:Int 0))) (Eq:Bool (list_length:Int (matrix_get:List Int weight (Lit:Int 0))) (list_length:Int input))) (matmul_inv0:Bool agg.result col curr input row weight))) (matmul_ps:Bool weight input agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef matmul_inv0(agg.result, col, curr, input, row, weight)\nrow >= 0 and row <= matrix_length(weight) and agg.result == matrix_vec_mul(matrix_take(weight, row), input)\n\n\n\ndef matmul_inv1(col, curr, input, weight, agg.result, row)\nrow >= 0 and row < matrix_length(weight) and col >= 0 and col <= list_length(input) and curr == reduce_sum(vec_elemwise_mul(list_take(matrix_get(weight, row), col), list_take(input, col))) and agg.result == matrix_vec_mul(matrix_take(weight, row), input)\n\n\n\ndef matmul_ps(weight, input, matmul_rv)\nmatmul_rv == matrix_vec_mul(weight, input)\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\ndef VECTOR_OUTER_LOOP_INDEX()\nFalse\n\n\n\nmatmul synthesized: (matrix_vec_mul:List Int weight input)\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef matmul_np (weight, input):\n    return np.matmul(weight, input)\n\n####### glued code ########\n\ndef matmul_np_glued (weight, input):\n    weight = np.array(weight).astype(np.float32)\n    input = np.array(input).astype(np.float32)\n    return matmul_np(weight, input)\n\nSynthesis took 6.189157247543335 seconds\n",
        "stderr": ""
    },
    "polybench-gesummv": {
        "elapsed_time": 0.23771600700092677,
        "return_code": 1,
        "stdout": "Reading file tenspiler/polybench/cpp/for_synthesis/gesummv.cc:  tenspiler/polybench/cpp/for_synthesis/gesummv.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> kernel_gesummv(vector<vector<int>> A,\n                                   vector<vector<int>> B,\n                                   vector<int> x,\n                                   int alpha,\n                                   int beta) {\n    int N = A.size();\n\n    vector<int> tmp_out;\n    vector<int> y_out;\n\n    for (int i = 0; i < N; i++) {\n        int tmp_val = 0;\n        int y_val = 0;\n        for (int j = 0; j < A[0].size(); j++) {\n            tmp_val = A[i][j] * x[j] + tmp_val;\n            y_val = B[i][j] * x[j] + y_val;\n        }\n        y_val = alpha * tmp_val + beta * y_val;\n\n        tmp_out.push_back(tmp_val);\n        y_out.push_back(y_val);\n    }\n\n    vector<vector<int>> result;\n    result.push_back(tmp_out);\n    result.push_back(y_out);\n\n    return result;\n}\n\nReading file tenspiler/polybench/cpp/for_synthesis/gesummv.cc:  tenspiler/polybench/cpp/for_synthesis/gesummv.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> kernel_gesummv(vector<vector<int>> A,\n                                   vector<vector<int>> B,\n                                   vector<int> x,\n                                   int alpha,\n                                   int beta) {\n    int N = A.size();\n\n    vector<int> tmp_out;\n    vector<int> y_out;\n\n    for (int i = 0; i < N; i++) {\n        int tmp_val = 0;\n        int y_val = 0;\n        for (int j = 0; j < A[0].size(); j++) {\n            tmp_val = A[i][j] * x[j] + tmp_val;\n            y_val = B[i][j] * x[j] + y_val;\n        }\n        y_val = alpha * tmp_val + beta * y_val;\n\n        tmp_out.push_back(tmp_val);\n        y_out.push_back(y_val);\n    }\n\n    vector<vector<int>> result;\n    result.push_back(tmp_out);\n    result.push_back(y_out);\n\n    return result;\n}\n\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/polybench/auto/driver/gesummv_driver.py\", line 7, in <module>\n    driver, input_vars, gesummv = analyze_double_loops(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1172, in analyze_double_loops\n    compute_node = find_compute_from_file(file_path)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 781, in find_compute_from_file\n    compute_node = find_compute_from_node(root_node)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 741, in find_compute_from_node\n    assert len(inner_loop_compound_nodes) <= 1\nAssertionError\n"
    },
    "stack_overflow-add_two_arrays_by_comparing_sizes": {
        "elapsed_time": 0.29089577900049335,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/add_two_arrays_by_comparing_sizes.cc:  tenspiler/stack_overflow/cpp/for_synthesis/add_two_arrays_by_comparing_sizes.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<int> add_two_arrays_by_comparing_sizes(vector<int> a, vector<int> b) {\n    // combined_result_arr = np.zeros((a.shape[0],), dtype=a.dtype)\n    vector<int> combined_result_arr;\n    for (int i = 0; i < a.size(); ++i) {\n        // Initialize the element value to 0 (simulating np.zeros initialization)\n        int current_val = 0;\n\n        // if b[i] >= a[i]:\n        if (b[i] >= a[i]) {\n            // combined_result = a[i] + b[i]\n            int combined_result = a[i] + b[i];\n            // combined_result_arr[i] = combined_result\n            current_val = combined_result;\n        }\n\n        // Use push_back to build the array\n        combined_result_arr.push_back(current_val);\n    }\n    return combined_result_arr;\n}\nReading file tenspiler/stack_overflow/cpp/for_synthesis/add_two_arrays_by_comparing_sizes.cc:  tenspiler/stack_overflow/cpp/for_synthesis/add_two_arrays_by_comparing_sizes.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<int> add_two_arrays_by_comparing_sizes(vector<int> a, vector<int> b) {\n    // combined_result_arr = np.zeros((a.shape[0],), dtype=a.dtype)\n    vector<int> combined_result_arr;\n    for (int i = 0; i < a.size(); ++i) {\n        // Initialize the element value to 0 (simulating np.zeros initialization)\n        int current_val = 0;\n\n        // if b[i] >= a[i]:\n        if (b[i] >= a[i]) {\n            // combined_result = a[i] + b[i]\n            int combined_result = a[i] + b[i];\n            // combined_result_arr[i] = combined_result\n            current_val = combined_result;\n        }\n\n        // Use push_back to build the array\n        combined_result_arr.push_back(current_val);\n    }\n    return combined_result_arr;\n}\nIf condition: (b[i] >= a[i])\nIf then statement: {\n            // combined_result = a[i] + b[i]\n            int combined_result = a[i] + b[i];\n            // combined_result_arr[i] = combined_result\n            current_val = combined_result;\n        }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: bb15\nname: bb14\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'bb15', 'bb14', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %current_val = alloca i32, align 4\n  %combined_result = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/add_two_arrays_by_comparing_sizes_driver.py\", line 15, in <module>\n    add_two_arrays_by_comparing_sizes(a, b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1138, in inv_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-derivative_1D": {
        "elapsed_time": 0.3129029480005556,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/derivative_1D.cc:  tenspiler/stack_overflow/cpp/for_synthesis/derivative_1D.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> derivative_1D(vector<int> x) {\n    vector<vector<int>> df;\n    for (int mu = 0; mu < x.size(); mu++) {\n        vector<int> row_vec;\n        for (int i = 0; i < x.size(); i++) {\n            int val = 0;\n            if (mu == i) {\n                val = 2 * x[i];\n            }\n            row_vec.push_back(val);\n        }\n        df.push_back(row_vec);\n    }\n    return df;\n}\nReading file tenspiler/stack_overflow/cpp/for_synthesis/derivative_1D.cc:  tenspiler/stack_overflow/cpp/for_synthesis/derivative_1D.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> derivative_1D(vector<int> x) {\n    vector<vector<int>> df;\n    for (int mu = 0; mu < x.size(); mu++) {\n        vector<int> row_vec;\n        for (int i = 0; i < x.size(); i++) {\n            int val = 0;\n            if (mu == i) {\n                val = 2 * x[i];\n            }\n            row_vec.push_back(val);\n        }\n        df.push_back(row_vec);\n    }\n    return df;\n}\nIf condition: (mu == i)\nIf then statement: {\n                val = 2 * x[i];\n            }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb12\nname: for.end\nname: invoke.cont9\nname: for.inc10<latch>\nname: bb11\nname: for.body5\nname: bb14\nname: bb13\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb11\nname: for.body5\nname: bb14\nname: bb13\nname: if.then\nname: if.end\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb12', 'for.end', 'invoke.cont9', 'bb11', 'for.body5', 'bb14', 'bb13', 'if.then', 'if.end', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc10']\nfound loop: header: for.cond1, body: ['bb11', 'for.body5', 'bb14', 'bb13', 'if.then', 'if.end', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %mu = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %i = alloca i32, align 4\n  %val = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %mu, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/derivative_1D_driver.py\", line 14, in <module>\n    derivative_1D(x)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-form_elementwise_list": {
        "elapsed_time": 0.22531501400044363,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/form_elementwise_list.cc:  tenspiler/stack_overflow/cpp/for_synthesis/form_elementwise_list.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<vector<int>>> calculate_form_elementwise_list(vector<vector<int>> a, int s)\n{\n    vector<vector<vector<int>>> result;\n    int m = a.size();\n    int n = a[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<vector<int>> plane;\n        for (int j = 0; j < n; j++) {\n            vector<int> pair_vec;\n            pair_vec.push_back(s);\n            pair_vec.push_back(a[i][j]);\n            plane.push_back(pair_vec);\n        }\n        result.push_back(plane);\n    }\n    return result;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/form_elementwise_list.cc:  tenspiler/stack_overflow/cpp/for_synthesis/form_elementwise_list.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<vector<int>>> calculate_form_elementwise_list(vector<vector<int>> a, int s)\n{\n    vector<vector<vector<int>>> result;\n    int m = a.size();\n    int n = a[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<vector<int>> plane;\n        for (int j = 0; j < n; j++) {\n            vector<int> pair_vec;\n            pair_vec.push_back(s);\n            pair_vec.push_back(a[i][j]);\n            plane.push_back(pair_vec);\n        }\n        result.push_back(plane);\n    }\n    return result;\n}\n\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/form_elementwise_list_driver.py\", line 7, in <module>\n    driver, input_vars, form_elementwise_list = analyze_double_loops(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1172, in analyze_double_loops\n    compute_node = find_compute_from_file(file_path)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 781, in find_compute_from_file\n    compute_node = find_compute_from_node(root_node)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 705, in find_compute_from_node\n    raise ParserError(\ntenspiler.tree_parser.ParserError: Expected <= 1 push statements in the innermost loop, but found 3\n"
    },
    "stack_overflow-looped_copy": {
        "elapsed_time": 4.667360252000435,
        "return_code": 0,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/looped_copy.cc:  tenspiler/stack_overflow/cpp/for_synthesis/looped_copy.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<vector<int>> looped_copy(vector<vector<int>> u_50, vector<vector<int>> u) {\n    vector<vector<int>> out;\n    for (int i = 0; i < u_50.size(); ++i) {\n        vector<int> row_vec;\n        for (int j = 0; j < u_50[0].size(); ++j) {\n            row_vec.push_back(u[i][j]);\n        }\n        out.push_back(row_vec);\n    }\n    return out;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/looped_copy.cc:  tenspiler/stack_overflow/cpp/for_synthesis/looped_copy.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<vector<int>> looped_copy(vector<vector<int>> u_50, vector<vector<int>> u) {\n    vector<vector<int>> out;\n    for (int i = 0; i < u_50.size(); ++i) {\n        vector<int> row_vec;\n        for (int j = 0; j < u_50[0].size(); ++j) {\n            row_vec.push_back(u[i][j]);\n        }\n        out.push_back(row_vec);\n    }\n    return out;\n}\n\nPush statement: row_vec.push_back(u[i][j])\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb10\nname: for.end\nname: invoke.cont11\nname: for.inc12<latch>\nname: bb9\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb9\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb10', 'for.end', 'invoke.cont11', 'bb9', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc12']\nfound loop: header: for.cond1, body: ['bb9', 'for.body6', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %conv = sext i32 %i2 to i64\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %u_50) #10\n  %cmp = icmp ult i64 %conv, %call\n  br i1 %cmp, label %bb, label %bb8\n  br label %for.body\n  br label %for.end14\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector.0\"* %row_vec) #10\n  store i32 0, i32* %j, align 4\n  br label %for.cond1\n  %i3 = load i32, i32* %j, align 4\n  %conv2 = sext i32 %i3 to i64\n  %call3 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %u_50, i64 0) #10\n  %call4 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call3) #10\n  %cmp5 = icmp ult i64 %conv2, %call4\n  br i1 %cmp5, label %bb9, label %bb10\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %bb11, label %bb12\n  br label %for.body6\n  br label %for.end\n  br label %nrvo.skipdtor\n  br label %nrvo.unused\n  %i4 = load i32, i32* %i, align 4\n  %conv7 = sext i32 %i4 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %u, i64 %conv7) #10\n  %i5 = load i32, i32* %j, align 4\n  %conv9 = sext i32 %i5 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #10\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %call10)\n  br label %invoke.cont\n  br label %for.inc\n  %i6 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i6, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont11\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED2Ev(%\"class.std::__1::vector.0\"* %row_vec) #10\n  br label %for.inc12\n  %i7 = load i32, i32* %i, align 4\n  %inc13 = add nsw i32 %i7, 1\n  store i32 %inc13, i32* %i, align 4\n  br label %for.cond\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int u_50)))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i (matrix_length:Int u_50)))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50))) (looped_copy_ps:Bool u_50 u agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1)) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool (matrix_empty:List Int ) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ) u u_50)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (matrix_length:Int u_50)) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50)) (looped_copy_inv1:Bool (Lit:Int 0) (list_empty:List Int ) u u_50 agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0)))) (Lt:Bool i (matrix_length:Int u_50))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50)) (looped_copy_inv1:Bool j row_vec u u_50 agg.result i)) (looped_copy_inv1:Bool (Add:Int j (Lit:Int 1)) (list_append:List List Int row_vec (list_get:Int (matrix_get:List Int u i) j)) u u_50 agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))))) (Lt:Bool i (matrix_length:Int u_50))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50)) (looped_copy_inv1:Bool j row_vec u u_50 agg.result i)) (looped_copy_inv0:Bool (matrix_append:List List Int agg.result row_vec) (Add:Int i (Lit:Int 1)) j row_vec u u_50)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int u_50)))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50)) (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i (matrix_length:Int u_50)))) (Ge:Bool (matrix_length:Int u_50) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u_50 (Lit:Int 0))) (Lit:Int 1))) (Ge:Bool (matrix_length:Int u) (Lit:Int 1))) (Ge:Bool (list_length:Int (matrix_get:List Int u (Lit:Int 0))) (Lit:Int 1))) (Eq:Bool (matrix_length:Int u_50) (matrix_length:Int u))) (looped_copy_inv0:Bool agg.result i j row_vec u u_50))) (looped_copy_ps:Bool u_50 u agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef looped_copy_inv0(agg.result, i, j, row_vec, u, u_50)\ni >= 0 and i <= matrix_length(u_50) and agg.result == matrix_col_slice(matrix_row_slice(u, 0, i), 0, list_length(matrix_get(u_50, 0)))\n\n\n\ndef looped_copy_inv1(j, row_vec, u, u_50, agg.result, i)\ni >= 0 and i < matrix_length(u_50) and j >= 0 and j <= list_length(matrix_get(u_50, 0)) and row_vec == vec_slice(matrix_get(u, i), 0, j) and agg.result == matrix_col_slice(matrix_row_slice(agg.result, 0, i), 0, list_length(matrix_get(u_50, 0)))\n\n\n\ndef looped_copy_ps(u_50, u, looped_copy_rv)\nlooped_copy_rv == matrix_col_slice(matrix_row_slice(u, 0, matrix_length(u_50)), 0, list_length(matrix_get(u_50, 0)))\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nlooped_copy synthesized: (matrix_col_slice:List Int (matrix_row_slice:List Int u (Lit:Int 0) (matrix_length:Int u_50)) (Lit:Int 0) (list_length:Int (matrix_get:Int u_50 (Lit:Int 0))))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef looped_copy_np (u_50, u):\n    return u[0:u_50.size][:, 0:u_50[0].size]\n\n####### glued code ########\n\ndef looped_copy_np_glued (u_50, u):\n    u_50 = np.array(u_50).astype(np.int32)\n    u = np.array(u).astype(np.int32)\n    return looped_copy_np(u_50, u)\n\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\n"
    },
    "stack_overflow-mask_generation": {
        "elapsed_time": 0.35805498599984276,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/mask_generation.cc:  tenspiler/stack_overflow/cpp/for_synthesis/mask_generation.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<vector<int>> mask_generation(vector<int> V) {\n    vector<vector<int>> x;\n    for (int i = 0; i < V.size(); ++i) {\n        vector<int> row_vec;\n        for (int j = 0; j < 20; ++j) {\n            if (j < V[i]) {\n                row_vec.push_back(1);\n            } else {\n                row_vec.push_back(0);\n            }\n        }\n        x.push_back(row_vec);\n    }\n    return x;\n}\nReading file tenspiler/stack_overflow/cpp/for_synthesis/mask_generation.cc:  tenspiler/stack_overflow/cpp/for_synthesis/mask_generation.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nvector<vector<int>> mask_generation(vector<int> V) {\n    vector<vector<int>> x;\n    for (int i = 0; i < V.size(); ++i) {\n        vector<int> row_vec;\n        for (int j = 0; j < 20; ++j) {\n            if (j < V[i]) {\n                row_vec.push_back(1);\n            } else {\n                row_vec.push_back(0);\n            }\n        }\n        x.push_back(row_vec);\n    }\n    return x;\n}\nIf condition: (j < V[i])\nIf then statement: {\n                row_vec.push_back(1);\n            }\nIf else statement: else {\n                row_vec.push_back(0);\n            }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb11\nname: for.end\nname: invoke.cont9\nname: for.inc10<latch>\nname: bb10\nname: for.body3\nname: bb13\nname: if.else\nname: invoke.cont8\nname: bb12\nname: if.then\nname: invoke.cont\nname: if.end\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb10\nname: for.body3\nname: bb13\nname: if.else\nname: invoke.cont8\nname: bb12\nname: if.then\nname: invoke.cont\nname: if.end\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb11', 'for.end', 'invoke.cont9', 'bb10', 'for.body3', 'bb13', 'if.else', 'invoke.cont8', 'bb12', 'if.then', 'invoke.cont', 'if.end', 'for.inc'], exits: ['for.cond'], latches: ['for.inc10']\nfound loop: header: for.cond1, body: ['bb10', 'for.body3', 'bb13', 'if.else', 'invoke.cont8', 'bb12', 'if.then', 'invoke.cont', 'if.end'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %ref.tmp7 = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/mask_generation_driver.py\", line 14, in <module>\n    mask_generation(V)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 595, in preorder_traversal_with_objs\n    then_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-max_temp_in_thirty_days": {
        "elapsed_time": 0.2725600880003185,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/max_temp_in_thirty_days.cc:  tenspiler/stack_overflow/cpp/for_synthesis/max_temp_in_thirty_days.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nint max_temp_in_thirty_days(vector<int> data, vector<int> periods) {\n    int maxtemp = -10000; // Representing negative infinity\n    for (int i = 0; i < periods.size(); ++i) {\n        int temp = 0;\n        for (int j = 0; j < 30; ++j) {\n            temp = temp + data[i + j];\n        }\n        if (temp > maxtemp) {\n            maxtemp = temp;\n        }\n    }\n    return maxtemp;\n}\nReading file tenspiler/stack_overflow/cpp/for_synthesis/max_temp_in_thirty_days.cc:  tenspiler/stack_overflow/cpp/for_synthesis/max_temp_in_thirty_days.cc\nSource code: #include <vector>\n\nusing namespace std;\n\nint max_temp_in_thirty_days(vector<int> data, vector<int> periods) {\n    int maxtemp = -10000; // Representing negative infinity\n    for (int i = 0; i < periods.size(); ++i) {\n        int temp = 0;\n        for (int j = 0; j < 30; ++j) {\n            temp = temp + data[i + j];\n        }\n        if (temp > maxtemp) {\n            maxtemp = temp;\n        }\n    }\n    return maxtemp;\n}\nIf condition: (temp > maxtemp)\nIf then statement: {\n            maxtemp = temp;\n        }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb15\nname: for.end\nname: bb17\nname: bb16\nname: if.then\nname: if.end\nname: for.inc8<latch>\nname: bb14\nname: for.body3\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb14\nname: for.body3\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb15', 'for.end', 'bb17', 'bb16', 'if.then', 'if.end', 'bb14', 'for.body3', 'for.inc'], exits: ['for.cond'], latches: ['for.inc8']\nfound loop: header: for.cond1, body: ['bb14', 'for.body3'], exits: ['for.cond1'], latches: ['for.inc']\n  %maxtemp = alloca i32, align 4\n  %i = alloca i32, align 4\n  %temp = alloca i32, align 4\n  %j = alloca i32, align 4\n  store i32 -10000, i32* %maxtemp, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/max_temp_in_thirty_days_driver.py\", line 15, in <module>\n    max_temp_in_thirty_days(data, periods)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-relative_difference": {
        "elapsed_time": 0.3731195599993953,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/relative_difference.cc:  tenspiler/stack_overflow/cpp/for_synthesis/relative_difference.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> calculate_relative_difference(vector<int> a) {\n    vector<vector<int>> rel_diff;\n    int n = a.size();\n\n    for (int j = 0; j < n; j++) {\n        vector<int> row_vec;\n        for (int i = 0; i < n; i++) {\n            row_vec.push_back((a[j] - a[i]) / a[i] * 100);\n        }\n        rel_diff.push_back(row_vec);\n    }\n    return rel_diff;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/relative_difference.cc:  tenspiler/stack_overflow/cpp/for_synthesis/relative_difference.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> calculate_relative_difference(vector<int> a) {\n    vector<vector<int>> rel_diff;\n    int n = a.size();\n\n    for (int j = 0; j < n; j++) {\n        vector<int> row_vec;\n        for (int i = 0; i < n; i++) {\n            row_vec.push_back((a[j] - a[i]) / a[i] * 100);\n        }\n        rel_diff.push_back(row_vec);\n    }\n    return rel_diff;\n}\n\nPush statement: row_vec.push_back((a[j] - a[i]) / a[i] * 100)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb16\nname: for.end\nname: invoke.cont10\nname: for.inc11<latch>\nname: bb15\nname: for.body3\nname: invoke.cont\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb15\nname: for.body3\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb16', 'for.end', 'invoke.cont10', 'bb15', 'for.body3', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc11']\nfound loop: header: for.cond1, body: ['bb15', 'for.body3', 'invoke.cont'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %n = alloca i32, align 4\n  %j = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %a) #10\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %n, align 4\n  store i32 0, i32* %j, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/relative_difference_driver.py\", line 14, in <module>\n    relative_difference(a)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 530, in preorder_traversal_with_objs\n    left_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 530, in preorder_traversal_with_objs\n    left_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 530, in preorder_traversal_with_objs\n    left_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 501, in preorder_traversal_with_objs\n    return choose(*vars_by_type_str[type_expr_tree])\nKeyError: 'matrix'\n"
    },
    "stack_overflow-set_one_in_columns": {
        "elapsed_time": 0.4104199890007294,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/set_one_in_columns.cc:  tenspiler/stack_overflow/cpp/for_synthesis/set_one_in_columns.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> set_one_in_columns(vector<vector<int>> x, vector<int> y)\n{\n    vector<vector<int>> out;\n    int m = y.size();\n    int n = x[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row_vec;\n        int num = y[i];\n        for (int j = 0; j < n; j++) {\n            if (j >= num)\n                row_vec.push_back(1);\n            else\n                row_vec.push_back(0);\n        }\n        out.push_back(row_vec);\n    }\n\n    return out;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/set_one_in_columns.cc:  tenspiler/stack_overflow/cpp/for_synthesis/set_one_in_columns.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> set_one_in_columns(vector<vector<int>> x, vector<int> y)\n{\n    vector<vector<int>> out;\n    int m = y.size();\n    int n = x[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row_vec;\n        int num = y[i];\n        for (int j = 0; j < n; j++) {\n            if (j >= num)\n                row_vec.push_back(1);\n            else\n                row_vec.push_back(0);\n        }\n        out.push_back(row_vec);\n    }\n\n    return out;\n}\n\nIf condition: (j >= num)\nIf then statement: row_vec.push_back(1);\nIf else statement: else\n                row_vec.push_back(0);\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond6\nname: bb14\nname: for.end\nname: invoke.cont12\nname: for.inc13<latch>\nname: bb13\nname: for.body8\nname: bb16\nname: if.else\nname: invoke.cont11\nname: bb15\nname: if.then\nname: invoke.cont\nname: if.end\nname: for.inc\nname: for.cond6<header><exiting>\nname: bb13\nname: for.body8\nname: bb16\nname: if.else\nname: invoke.cont11\nname: bb15\nname: if.then\nname: invoke.cont\nname: if.end\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond6', 'bb14', 'for.end', 'invoke.cont12', 'bb13', 'for.body8', 'bb16', 'if.else', 'invoke.cont11', 'bb15', 'if.then', 'invoke.cont', 'if.end', 'for.inc'], exits: ['for.cond'], latches: ['for.inc13']\nfound loop: header: for.cond6, body: ['bb13', 'for.body8', 'bb16', 'if.else', 'invoke.cont11', 'bb15', 'if.then', 'invoke.cont', 'if.end'], exits: ['for.cond6'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %num = alloca i32, align 4\n  %j = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %ref.tmp10 = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %y) #10\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %x, i64 0) #10\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #10\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/set_one_in_columns_driver.py\", line 16, in <module>\n    set_one_in_columns(x, y)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 595, in preorder_traversal_with_objs\n    then_expr = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: call_expression\n"
    },
    "stack_overflow-square_plus_one": {
        "elapsed_time": 10.883005935000256,
        "return_code": 0,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/square_plus_one.cc:  tenspiler/stack_overflow/cpp/for_synthesis/square_plus_one.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> square_plus_one(vector<vector<int>> arr_in)\n{\n    vector<vector<int>> result;\n    int m = arr_in.size();\n    int n = arr_in[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row_vec;\n        for (int j = 0; j < n; j++) {\n            int value = arr_in[i][j];\n            int dbl = value * value + 1;\n            row_vec.push_back(dbl);\n        }\n        result.push_back(row_vec);\n    }\n    return result;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/square_plus_one.cc:  tenspiler/stack_overflow/cpp/for_synthesis/square_plus_one.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<vector<int>> square_plus_one(vector<vector<int>> arr_in)\n{\n    vector<vector<int>> result;\n    int m = arr_in.size();\n    int n = arr_in[0].size();\n\n    for (int i = 0; i < m; i++) {\n        vector<int> row_vec;\n        for (int j = 0; j < n; j++) {\n            int value = arr_in[i][j];\n            int dbl = value * value + 1;\n            row_vec.push_back(dbl);\n        }\n        result.push_back(row_vec);\n    }\n    return result;\n}\n\nPush statement: row_vec.push_back(dbl)\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond4\nname: bb15\nname: for.end\nname: invoke.cont11\nname: for.inc12<latch>\nname: bb14\nname: for.body6\nname: invoke.cont\nname: for.inc\nname: for.cond4<header><exiting>\nname: bb14\nname: for.body6\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond4', 'bb15', 'for.end', 'invoke.cont11', 'bb14', 'for.body6', 'invoke.cont', 'for.inc'], exits: ['for.cond'], latches: ['for.inc12']\nfound loop: header: for.cond4, body: ['bb14', 'for.body6', 'invoke.cont'], exits: ['for.cond4'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %m = alloca i32, align 4\n  %n = alloca i32, align 4\n  %i = alloca i32, align 4\n  %row_vec = alloca %\"class.std::__1::vector.0\", align 8\n  %j = alloca i32, align 4\n  %value = alloca i32, align 4\n  %dbl = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call i64 @_ZNKSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE4sizeEv(%\"class.std::__1::vector\"* %arr_in) #10\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %m, align 4\n  %call1 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %arr_in, i64 0) #10\n  %call2 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector.0\"* %call1) #10\n  %conv3 = trunc i64 %call2 to i32\n  store i32 %conv3, i32* %n, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n  %i2 = load i32, i32* %i, align 4\n  %i3 = load i32, i32* %m, align 4\n  %cmp = icmp slt i32 %i2, %i3\n  br i1 %cmp, label %bb, label %bb13\n  br label %for.body\n  br label %for.end14\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector.0\"* %row_vec) #10\n  store i32 0, i32* %j, align 4\n  br label %for.cond4\n  %i4 = load i32, i32* %j, align 4\n  %i5 = load i32, i32* %n, align 4\n  %cmp5 = icmp slt i32 %i4, %i5\n  br i1 %cmp5, label %bb14, label %bb15\n  store i1 true, i1* %nrvo, align 1\n  %nrvo.val = load i1, i1* %nrvo, align 1\n  br i1 %nrvo.val, label %bb16, label %bb17\n  br label %for.body6\n  br label %for.end\n  br label %nrvo.skipdtor\n  br label %nrvo.unused\n  %i6 = load i32, i32* %i, align 4\n  %conv7 = sext i32 %i6 to i64\n  %call8 = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector.0\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector\"* %arr_in, i64 %conv7) #10\n  %i7 = load i32, i32* %j, align 4\n  %conv9 = sext i32 %i7 to i64\n  %call10 = call nonnull align 4 dereferenceable(4) i32* @_ZNSt3__16vectorIiNS_9allocatorIiEEEixEm(%\"class.std::__1::vector.0\"* %call8, i64 %conv9) #10\n  %i8 = load i32, i32* %call10, align 4\n  store i32 %i8, i32* %value, align 4\n  %i9 = load i32, i32* %value, align 4\n  %i10 = load i32, i32* %value, align 4\n  %mul = mul nsw i32 %i9, %i10\n  %add = add nsw i32 %mul, 1\n  store i32 %add, i32* %dbl, align 4\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEE9push_backERKi(%\"class.std::__1::vector.0\"* %row_vec, i32* nonnull align 4 dereferenceable(4) %dbl)\n  br label %invoke.cont\n  br label %for.inc\n  %i11 = load i32, i32* %j, align 4\n  %inc = add nsw i32 %i11, 1\n  store i32 %inc, i32* %j, align 4\n  br label %for.cond4\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEE9push_backERKS3_(%\"class.std::__1::vector\"* %agg.result, %\"class.std::__1::vector.0\"* nonnull align 8 dereferenceable(24) %row_vec)\n  br label %invoke.cont11\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEED2Ev(%\"class.std::__1::vector.0\"* %row_vec) #10\n  br label %for.inc12\n  %i12 = load i32, i32* %i, align 4\n  %inc13 = add nsw i32 %i12, 1\n  store i32 %inc13, i32* %i, align 4\n  br label %for.cond\n  call void @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEED2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  br label %nrvo.skipdtor\n  ret void\nps: (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int arr_in)))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value)) (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i (matrix_length:Int arr_in)))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value))) (square_plus_one_ps:Bool arr_in agg.result))\nStarting synthesis at list bound 2\nTrying strict grammar with list bound 2...\nasserts: [(Implies:Bool (And:Bool (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2)) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool (matrix_empty:List Int ) arr_in (Lit:Int 0) (Lit:Int 0) (Lit:Int 0) (list_empty:List Int ) (Lit:Int 0))), (Implies:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool i (matrix_length:Int arr_in)) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value)) (square_plus_one_inv1:Bool arr_in dbl (Lit:Int 0) (list_empty:List Int ) value agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0)))) (Lt:Bool i (matrix_length:Int arr_in))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value)) (square_plus_one_inv1:Bool arr_in dbl j row_vec value agg.result i)) (square_plus_one_inv1:Bool arr_in (Add:Int (Mul:Int (list_get:Int (matrix_get:List Int arr_in i) j) (list_get:Int (matrix_get:List Int arr_in i) j)) (Lit:Int 1)) (Add:Int j (Lit:Int 1)) (list_append:List List Int row_vec (Add:Int (Mul:Int (list_get:Int (matrix_get:List Int arr_in i) j) (list_get:Int (matrix_get:List Int arr_in i) j)) (Lit:Int 1))) (list_get:Int (matrix_get:List Int arr_in i) j) agg.result i)), (Implies:Bool (And:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lt:Bool j (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))))) (Lt:Bool i (matrix_length:Int arr_in))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value)) (square_plus_one_inv1:Bool arr_in dbl j row_vec value agg.result i)) (square_plus_one_inv0:Bool (matrix_append:List List Int agg.result row_vec) arr_in dbl (Add:Int i (Lit:Int 1)) j row_vec value)), (Implies:Bool (Or:Bool (And:Bool (And:Bool (And:Bool (And:Bool (Not:Bool (Lit:Bool True)) (Not:Bool (Lt:Bool i (matrix_length:Int arr_in)))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value)) (And:Bool (And:Bool (And:Bool (And:Bool (Lit:Bool True) (Not:Bool (Lt:Bool i (matrix_length:Int arr_in)))) (Eq:Bool (matrix_length:Int arr_in) (Lit:Int 2))) (Ge:Bool (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))) (Lit:Int 1))) (square_plus_one_inv0:Bool agg.result arr_in dbl i j row_vec value))) (square_plus_one_ps:Bool arr_in agg.result))]\n====== verification of round 0 solution ======\nNot verifying solution\nSynthesized PS and INV Candidates\n\ndef square_plus_one_inv0(agg.result, arr_in, dbl, i, j, row_vec, value)\ni >= 0 and i <= matrix_length(arr_in) and agg.result == matrix_scalar_add(1, matrix_elemwise_mul(matrix_col_slice(matrix_row_slice(arr_in, 0, i), 0, list_length(matrix_get(arr_in, 0))), matrix_col_slice(matrix_row_slice(arr_in, 0, i), 0, list_length(matrix_get(arr_in, 0)))))\n\n\n\ndef square_plus_one_inv1(arr_in, dbl, j, row_vec, value, agg.result, i)\ni >= 0 and i < matrix_length(arr_in) and j >= 0 and j <= list_length(matrix_get(arr_in, 0)) and row_vec == vec_scalar_add(1, vec_elemwise_mul(vec_slice(matrix_get(arr_in, i), 0, j), vec_slice(matrix_get(arr_in, i), 0, j))) and agg.result == matrix_scalar_add(1, matrix_elemwise_mul(matrix_col_slice(matrix_row_slice(arr_in, 0, i), 0, list_length(matrix_get(arr_in, 0))), matrix_col_slice(matrix_row_slice(arr_in, 0, i), 0, list_length(matrix_get(arr_in, 0)))))\n\n\n\ndef square_plus_one_ps(arr_in, square_plus_one_rv)\nsquare_plus_one_rv == matrix_scalar_add(1, matrix_elemwise_mul(matrix_col_slice(matrix_row_slice(arr_in, 0, matrix_length(arr_in)), 0, list_length(matrix_get(arr_in, 0))), matrix_col_slice(matrix_row_slice(arr_in, 0, matrix_length(arr_in)), 0, list_length(matrix_get(arr_in, 0)))))\n\n\n\ndef MATRIX_OUTER_LOOP_INDEX_FIRST()\nTrue\n\n\n\nsquare_plus_one synthesized: (matrix_scalar_add:List Int (Lit:Int 1) (matrix_elemwise_mul:List Int (matrix_col_slice:List Int (matrix_row_slice:List Int arr_in (Lit:Int 0) (matrix_length:Int arr_in)) (Lit:Int 0) (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0)))) (matrix_col_slice:List Int (matrix_row_slice:List Int arr_in (Lit:Int 0) (matrix_length:Int arr_in)) (Lit:Int 0) (list_length:Int (matrix_get:List Int arr_in (Lit:Int 0))))))\n\n####### import statements ########\nimport numpy as np\n\n####### kernel code ########\n\ndef square_plus_one_np (arr_in):\n    return (1) + ((arr_in[0:arr_in.size][:, 0:arr_in[0].size]) * (arr_in[0:arr_in.size][:, 0:arr_in[0].size]))\n\n####### glued code ########\n\ndef square_plus_one_np_glued (arr_in):\n    arr_in = np.array(arr_in).astype(np.int32)\n    return square_plus_one_np(arr_in)\n\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\n"
    },
    "stack_overflow-struct_function": {
        "elapsed_time": 0.37982093099890335,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/struct_function.cc:  tenspiler/stack_overflow/cpp/for_synthesis/struct_function.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> structFunPython(vector<int> f, vector<int> sf2)\n{\n    vector<int> result;\n\n    for (int i = 0; i < sf2.size(); i++) {\n        int count = 0;\n        int sf2_val = sf2[i];\n\n        for (int j = 0; j < f.size(); j++) {\n            if ((j >= 1) && (j < f.size() - i)) {\n                int diff = f[i + j] - f[i];\n                sf2_val = sf2_val + diff * diff;\n                count = count + 1;\n            }\n        }\n\n        result.push_back(sf2_val / count);\n    }\n\n    return result;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/struct_function.cc:  tenspiler/stack_overflow/cpp/for_synthesis/struct_function.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> structFunPython(vector<int> f, vector<int> sf2)\n{\n    vector<int> result;\n\n    for (int i = 0; i < sf2.size(); i++) {\n        int count = 0;\n        int sf2_val = sf2[i];\n\n        for (int j = 0; j < f.size(); j++) {\n            if ((j >= 1) && (j < f.size() - i)) {\n                int diff = f[i + j] - f[i];\n                sf2_val = sf2_val + diff * diff;\n                count = count + 1;\n            }\n        }\n\n        result.push_back(sf2_val / count);\n    }\n\n    return result;\n}\n\nIf condition: ((j >= 1) && (j < f.size() - i))\nIf then statement: {\n                int diff = f[i + j] - f[i];\n                sf2_val = sf2_val + diff * diff;\n                count = count + 1;\n            }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond3\nname: bb24\nname: for.end\nname: invoke.cont\nname: for.inc20<latch>\nname: bb23\nname: for.body7\nname: bb26\nname: bb25\nname: land.lhs.true\nname: bb28\nname: bb27\nname: if.then\nname: if.end\nname: for.inc\nname: for.cond3<header><exiting>\nname: bb23\nname: for.body7\nname: bb26\nname: bb25\nname: land.lhs.true\nname: bb28\nname: bb27\nname: if.then\nname: if.end\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond3', 'bb24', 'for.end', 'invoke.cont', 'bb23', 'for.body7', 'bb26', 'bb25', 'land.lhs.true', 'bb28', 'bb27', 'if.then', 'if.end', 'for.inc'], exits: ['for.cond'], latches: ['for.inc20']\nfound loop: header: for.cond3, body: ['bb23', 'for.body7', 'bb26', 'bb25', 'land.lhs.true', 'bb28', 'bb27', 'if.then', 'if.end'], exits: ['for.cond3'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %i = alloca i32, align 4\n  %count = alloca i32, align 4\n  %sf2_val = alloca i32, align 4\n  %j = alloca i32, align 4\n  %diff = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/struct_function_driver.py\", line 15, in <module>\n    struct_function(f, sf2)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-sum_columns": {
        "elapsed_time": 0.3396222999999736,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/sum_columns.cc:  tenspiler/stack_overflow/cpp/for_synthesis/sum_columns.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> calculate_sum_columns(vector<vector<int>> a, int c)\n{\n    vector<int> results;\n    int n = a[0].size();\n    for (int i = 0; i < n; i++) {\n        results.push_back(c * (a[0][i] + 2 * a[1][i] + 2 * a[2][i] + a[3][i]));\n    }\n    return results;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/sum_columns.cc:  tenspiler/stack_overflow/cpp/for_synthesis/sum_columns.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> calculate_sum_columns(vector<vector<int>> a, int c)\n{\n    vector<int> results;\n    int n = a[0].size();\n    for (int i = 0; i < n; i++) {\n        results.push_back(c * (a[0][i] + 2 * a[1][i] + 2 * a[2][i] + a[3][i]));\n    }\n    return results;\n}\n\nPush statement: results.push_back(c * (a[0][i] + 2 * a[1][i] + 2 * a[2][i] + a[3][i]))\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: invoke.cont\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'invoke.cont'], exits: ['for.cond'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %c.addr = alloca i32, align 4\n  %nrvo = alloca i1, align 1\n  %n = alloca i32, align 4\n  %i = alloca i32, align 4\n  %ref.tmp = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i1 = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i1, i8** %result.ptr, align 8\n  store i32 %c, i32* %c.addr, align 4\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call nonnull align 8 dereferenceable(24) %\"class.std::__1::vector\"* @_ZNSt3__16vectorINS0_IiNS_9allocatorIiEEEENS1_IS3_EEEixEm(%\"class.std::__1::vector.1\"* %a, i64 0) #10\n  %call1 = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %call) #10\n  %conv = trunc i64 %call1 to i32\n  store i32 %conv, i32* %n, align 4\n  store i32 0, i32* %i, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/sum_columns_driver.py\", line 15, in <module>\n    sum_columns(a, c)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1138, in inv_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1005, in get_outer_loop_inv\n    raise ParserError(\"is_outer_loop_index_first function is not provided\")\ntenspiler.tree_parser.ParserError: is_outer_loop_index_first function is not provided\n"
    },
    "stack_overflow-supply_demand": {
        "elapsed_time": 0.32359511200047564,
        "return_code": 1,
        "stdout": "Reading file tenspiler/stack_overflow/cpp/for_synthesis/supply_demand.cc:  tenspiler/stack_overflow/cpp/for_synthesis/supply_demand.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> supply_deman(vector<int> prices) {\n    vector<int> y;\n    int n = prices.size();\n\n    for (int m = 0; m < n; m++) {\n        int count = 0;\n        for (int p = 0; p < n; p++) {\n            if (prices[p] > prices[m]) {\n                count = count + 1;\n            }\n        }\n        y.push_back(count);\n    }\n    return y;\n}\n\nReading file tenspiler/stack_overflow/cpp/for_synthesis/supply_demand.cc:  tenspiler/stack_overflow/cpp/for_synthesis/supply_demand.cc\nSource code: #include <vector>\nusing namespace std;\n\nvector<int> supply_deman(vector<int> prices) {\n    vector<int> y;\n    int n = prices.size();\n\n    for (int m = 0; m < n; m++) {\n        int count = 0;\n        for (int p = 0; p < n; p++) {\n            if (prices[p] > prices[m]) {\n                count = count + 1;\n            }\n        }\n        y.push_back(count);\n    }\n    return y;\n}\n\nIf condition: (prices[p] > prices[m])\nIf then statement: {\n                count = count + 1;\n            }\nname: for.cond<header><exiting>\nname: bb\nname: for.body\nname: for.cond1\nname: bb14\nname: for.end\nname: invoke.cont\nname: for.inc9<latch>\nname: bb13\nname: for.body3\nname: bb16\nname: bb15\nname: if.then\nname: if.end\nname: for.inc\nname: for.cond1<header><exiting>\nname: bb13\nname: for.body3\nname: bb16\nname: bb15\nname: if.then\nname: if.end\nname: for.inc<latch>\nfound loop: header: for.cond, body: ['bb', 'for.body', 'for.cond1', 'bb14', 'for.end', 'invoke.cont', 'bb13', 'for.body3', 'bb16', 'bb15', 'if.then', 'if.end', 'for.inc'], exits: ['for.cond'], latches: ['for.inc9']\nfound loop: header: for.cond1, body: ['bb13', 'for.body3', 'bb16', 'bb15', 'if.then', 'if.end'], exits: ['for.cond1'], latches: ['for.inc']\n  %result.ptr = alloca i8*, align 8\n  %nrvo = alloca i1, align 1\n  %n = alloca i32, align 4\n  %m = alloca i32, align 4\n  %count = alloca i32, align 4\n  %p = alloca i32, align 4\n  %exn.slot = alloca i8*, align 8\n  %ehselector.slot = alloca i32, align 4\n  %i = bitcast %\"class.std::__1::vector\"* %agg.result to i8*\n  store i8* %i, i8** %result.ptr, align 8\n  store i1 false, i1* %nrvo, align 1\n  call void @_ZNSt3__16vectorIiNS_9allocatorIiEEEC2Ev(%\"class.std::__1::vector\"* %agg.result) #10\n  %call = call i64 @_ZNKSt3__16vectorIiNS_9allocatorIiEEE4sizeEv(%\"class.std::__1::vector\"* %prices) #10\n  %conv = trunc i64 %call to i32\n  store i32 %conv, i32* %n, align 4\n  store i32 0, i32* %m, align 4\n  br label %for.cond\n",
        "stderr": "/home/liujqian/miniconda3/envs/tenspiler/lib/python3.9/site-packages/tree_sitter/__init__.py:36: FutureWarning: Language(path, name) is deprecated. Use Language(ptr, name) instead.\n  warn(\"{} is deprecated. Use {} instead.\".format(old, new), FutureWarning)\nTraceback (most recent call last):\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/supply_demand_driver.py\", line 14, in <module>\n    supply_demand(prices)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1756, in __call__\n    v.visit_llvm_block(b)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 1259, in visit_llvm_block\n    inv.call(blk_state),\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 800, in call\n    self.gen_synth(relaxed_grammar=False)\n  File \"/home/liujqian/Documents/Repositories/tenspiler/metalift/frontend/llvm.py\", line 809, in gen_synth\n    body = self.grammar(self.writes, self.reads, self.in_scope, relaxed_grammar).src\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1215, in inv0_grammar\n    return get_outer_loop_inv(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 1024, in get_outer_loop_inv\n    obj_expr_tree = preorder_traversal_with_objs(\n  File \"/home/liujqian/Documents/Repositories/tenspiler/tenspiler/tree_parser.py\", line 621, in preorder_traversal_with_objs\n    raise ParserError(f\"Unsupported type: {type_expr_tree['type']}\")\ntenspiler.tree_parser.ParserError: Unsupported type: compound_statement\n"
    },
    "stack_overflow-+13zipped_loop_computation": {
        "elapsed_time": 0.08669373999873642,
        "return_code": 2,
        "stdout": "",
        "stderr": "python: can't open file '/home/liujqian/Documents/Repositories/tenspiler/tenspiler/stack_overflow/auto/driver/+13zipped_loop_computation_driver.py': [Errno 2] No such file or directory\n"
    }
}